#!/usr/bin/env bash
# =============================================================================
#  MuxMaster™ Freeware License v1.0
#  Copyright © 2025 Jamey Wicklund (theBluWiz)
#  Fork: Simplified Remux Tool (video passthrough, AAC audio, mov_text subs)
# =============================================================================
# HLG/HDR10/SDR → MP4 Remuxer with NVENC fallback encoding
# Requires: ffmpeg (with NVENC), ffprobe, MP4Box
# =============================================================================

set -eEuo pipefail
if shopt -q inherit_errexit 2>/dev/null; then shopt -s inherit_errexit; fi
[[ "${DEBUG:-0}" == "1" ]] && set -x

# ---------- Branding / CLI constants (locked; not configurable) ----------
readonly APP_NAME="MuxMaster"
readonly CLI_NAME="muxm"
readonly VERSION="1.2"

# ---------- Globals ----------
declare -a COMPLETED_STEPS=()
declare -a MUXM_CONFIG_LOADED=()
WORKDIR=""
LOGFILE=""
FAILED=0
FAIL_MSG=""
EXIT_CODE=1
PRINT_EFFCONF=0
CONFIG_WRITE_PROMPTED=0
CONFIG_WRITE_ROTATE=0
CONFIG_WRITE_PATH=""

# ---------- Opinionated defaults (lowest precedence) ----------
# Video encode (x265)
CRF_VALUE=18
PRESET_VALUE="slower"
X265_PARAMS_BASE='profile=main10:repeat-headers=1:hdr-opt=1:aq-mode=3:aq-strength=1.3:psy-rd=2.0:psy-rdoq=1.0:rc-lookahead=60'
LEVEL_VALUE=""                 # e.g., 5.1 (blank = encoder decides)
CONSERVATIVE_VBV=1
LEVEL_VBV_4_1_MAXRATE=10000k; LEVEL_VBV_4_1_BUFSIZE=20000k
LEVEL_VBV_5_0_MAXRATE=25000k; LEVEL_VBV_5_0_BUFSIZE=50000k
LEVEL_VBV_5_1_MAXRATE=40000k; LEVEL_VBV_5_1_BUFSIZE=80000k
LEVEL_VBV_5_2_MAXRATE=60000k; LEVEL_VBV_5_2_BUFSIZE=120000k

# Pixel format / chroma policy
FORCE_CHROMA_420=1
SDR_USE_10BIT_IF_SRC_10BIT=1
HDR_TARGET_PIXFMT="yuv420p10le"

# Threads
THREADS=""

# Video passthrough / NVENC encoding
VIDEO_PASSTHROUGH=0
SRC_VCODEC=""
USE_NVENC=1
NVENC_PRESET="p4"
NVENC_CQ=23
NVENC_TUNE="hq"
NVENC_GPU_INDEX=0

# Audio selection (preferences & weights)
AUDIO_LANG_PREF="eng"                 # comma-separated list
AUDIO_CODEC_PREFERENCE="eac3,ac3,aac,other"
AUDIO_SCORE_CHANNEL_MULTIPLIER=20
AUDIO_SCORE_SURROUND_BONUS=30
AUDIO_SCORE_LANG_BONUS_ENG=25

# Audio transcode policy
STEREO_BITRATE="192k"
MAX_AUDIO_CHANNELS=8
ADD_STEREO_IF_MULTICH=1
AAC_SURROUND_BITRATE_5_1="384k"
AAC_SURROUND_BITRATE_7_1="448k"
PARALLEL_AUDIO=0

# Muxing / output
OUTPUT_EXT="mp4"
MP4_INTERLEAVE_MS=500
TAG_LANGUAGE_DEFAULT="und"
INCLUDE_AUDIO_TITLES=1
MP4BOX_QUIET=1

# Operational defaults
CHECKSUM=0
DRY_RUN=0
KEEP_TEMP=0
KEEP_TEMP_ALWAYS=0
DISK_FREE_WARN_GB=5

# ffmpeg/ffprobe UX
FFMPEG_HIDE_BANNER=1
FFMPEG_LOGLEVEL="error"   # quiet|panic|fatal|error|warning|info|verbose|debug|trace
FFMPEG_OVERWRITE=1
FFPROBE_LOGLEVEL="error"

# Demux policy
ANNEXB_FOR_DEMUX=1

# ---------- Basic helpers ----------
say()  { printf "%s\n" "$@" >&2; }
note() { printf "ℹ️  %s\n" "$@" >&2; }
warn() { printf "⚠️  %s\n" "$@" >&2; }
die()  { local code=1; if [[ $# -gt 1 && "$1" =~ ^[0-9]+$ ]]; then code="$1"; shift; fi; FAILED=1; EXIT_CODE="$code"; FAIL_MSG="Fatal: $*"; printf "❌ ERROR: %s\n" "$FAIL_MSG" >&2; exit "$code"; }
on_error(){ local lineno="$1" cmd="$2" status="$3"; FAILED=1; EXIT_CODE="${EXIT_CODE:-$status}"; FAIL_MSG="Command failed at line $lineno: $cmd (exit $status)"; printf "❌ ERROR: %s\n" "$FAIL_MSG" >&2; }
mark_done(){ COMPLETED_STEPS+=("$1"); }
need(){ command -v "$1" >/dev/null 2>&1 || die 10 "Missing required tool: $1"; }
timestamp(){ date +"%Y-%m-%d %H:%M:%S"; }
realpath_fallback(){ if command -v realpath >/dev/null 2>/dev/null; then realpath "$1"; else echo "$(cd "$(dirname "$1")" && pwd)/$(basename "$1")"; fi; }
filesize_pretty(){
  if command -v gstat >/dev/null 2>/dev/null; then gstat -c "%n %s bytes" "$1"
  elif stat -f "%N %z bytes" /dev/null >/dev/null 2>&1; then stat -f "%N %z bytes" "$1"
  elif stat --printf '%n %s bytes\n' /dev/null >/dev/null 2>&1; then stat --printf '%n %s bytes\n' "$1"
  else ls -lh "$1"; fi
}
kill_if_running(){ local pid="${1:-}"; [[ -n "$pid" ]] || return 0; if kill -0 "$pid" 2>/dev/null; then kill "$pid" 2>/dev/null || true; fi; }
checksum_cmd(){ command -v sha256sum >/dev/null 2>/dev/null && { echo "sha256sum"; return; }; command -v shasum >/dev/null 2>/dev/null && { echo "shasum -a 256"; return; }; echo ""; }
write_checksum(){ local p="$1" c; c="$(checksum_cmd)"; [[ -z "$c" ]] && { warn "Checksum tool not found"; return 0; }; note "Writing checksum → ${p}.sha256"; $c "$p" > "${p}.sha256"; }

# DRY-RUN-safe copy helper
cp_or_dryrun() {
  local src="$1" dst="$2"
  if (( DRY_RUN )); then
    say "DRY-RUN: copy $src → $dst"
    : > "$dst"
  else
    cp -f "$src" "$dst"
  fi
}

# ---------- Write default .muxmrc (used by --install) ----------
_write_default_muxmrc() {
  local conf_path="$1"
  # Helper: write the full default config to a given path
  _write_template() {
    local _out="$1"
    umask 022
    cat >"$_out" <<'CONF'
    ... (config template content) ...
CONF
    chmod 0644 "$_out" || true
  }
  # If no file, write fresh
  if [[ ! -e "$conf_path" ]]; then
    _write_template "$conf_path"
    note "Wrote default config → $conf_path"
    return 0
  fi
  # File exists: prompt to overwrite
  say "Config already exists at: $conf_path"
  printf "Overwrite with default and back up the current file? [y/N]: " >&2
  local ans
  if ! read -r ans; then ans=""; fi
  case "$ans" in
    [Yy]|[Yy][Ee][Ss])
      local ts backup_dir backup_path
      ts="$(date +%Y%m%d-%H%M%S)"
      backup_dir="$(dirname -- "$conf_path")"
      backup_path="${backup_dir}/muxmrc.${ts}.bak"
      if cp -f "$conf_path" "$backup_path"; then
        note "Backed up current config → $backup_path"
      else
        warn "Could not back up existing config; proceeding with overwrite."
      fi
      _write_template "$conf_path"
      note "Overwrote config with updated defaults → $conf_path"
      ;;
    *)
      note "Keeping existing config. No changes made."
      ;;
  esac
}

# ---------- Config chain: Defaults → Global → User → Project ----------
# Loads only .muxmrc files, in strict precedence order.
# Resulting values can still be overridden by CLI flags later.

_muxm_try_source(){
  local f="$1"
  [[ -r "$f" ]] || return 0
  # shellcheck source=/dev/null
  . "$f" && MUXM_CONFIG_LOADED+=("$f")
}

# System-wide (lowest precedence after script defaults)
_muxm_try_source /etc/.muxmrc

# User-level
_muxm_try_source "$HOME/.muxmrc"

# Project-local (highest among configs; still below CLI args)
_muxm_try_source "./.muxmrc"

# Visibility: show which layers were actually loaded
if [[ ${#MUXM_CONFIG_LOADED[@]} -gt 0 ]]; then
  printf "ℹ️  Loaded config: %s\n" "${MUXM_CONFIG_LOADED[*]}" >&2
fi

# ---------- CLI parsing (highest precedence; overrides configs) ----------
USAGE_SHORT="Usage: ${CLI_NAME} [options] <source> [target.\${OUTPUT_EXT}]"
print_usage(){ cat <<'EOF'
Usage: muxm [options] <source.mkv|mp4|m4v|mov> [target.${OUTPUT_EXT}]

General:
  -h, --help                      Show help
  -V, --version                   Show version
      --install                   Install muxm to ~/.bin/muxm (no sudo), ensure ~/.bin in PATH,
                                  and create/update a default .muxmrc (with prompt + backup)
      --print-effective-config    Print the effective configuration and exit
      --config [PATH]             Write the current effective config to PATH (default: ./.muxmrc).
                                  If PATH exists, a timestamped sibling is written (no overwrite).

Operational:
      --dry-run                   Plan and print steps without writing output
      --checksum                  Write SHA-256 next to final output
      --no-checksum               Disable checksum
  -k, --keep-temp                 Keep workdir on FAILURE
  -K, --keep-temp-always          Keep workdir on SUCCESS and FAILURE
      --disk-free-warn-gb N      Warn if output volume has less than N GB free (default ${DISK_FREE_WARN_GB})

ffmpeg/ffprobe UX:
      --ffmpeg-loglevel LVL      quiet|panic|fatal|error|warning|info|verbose|debug|trace
      --no-hide-banner           Do not hide ffmpeg banner
      --no-overwrite             Do not pass -y to ffmpeg
      --ffprobe-loglevel LVL     Log level for ffprobe (default ${FFPROBE_LOGLEVEL})

Threads:
      --threads N                ffmpeg -threads N (empty = ffmpeg decides)

Video (x265):
  -p, --preset NAME              ultrafast..placebo (default ${PRESET_VALUE})
      --crf N                    Constant Rate Factor (default ${CRF_VALUE})
      --x265-params STR          Full x265 param string (overrides base)
  -l, --level N                  x265 level-idc (e.g., 5.1)
      --no-conservative-vbv      Disable conservative VBV for set level

Pixel format / chroma:
      --force-420                Downsample 422/444 → 420 (default on)
      --no-force-420             Keep source chroma
      --sdr-10bit-if-src         SDR uses 10-bit if source is 10-bit (default on)
      --no-sdr-10bit-if-src      Force SDR 8-bit
      --hdr-target-pixfmt FMT    e.g., yuv420p10le (default ${HDR_TARGET_PIXFMT})

NVENC Hardware Encoding:
      --nvenc                    Enable NVENC for non-passthrough encodes (default on)
      --no-nvenc                 Force CPU encoding (libx265)
      --nvenc-preset PRESET      p1 (fastest) to p7 (best quality), default p4
      --nvenc-cq VALUE           Constant quality 0-51 (default 23)
      --nvenc-gpu INDEX          GPU device index (default 0)

Audio selection:
      --audio-track N            Select specific audio index (0-based)
      --audio-lang-pref LIST     e.g., eng,spa,und (default ${AUDIO_LANG_PREF})
      --audio-codec-pref LIST    e.g., eac3,ac3,aac,other (default ${AUDIO_CODEC_PREFERENCE})
      --audio-score-chan-mul N   Weight for channels (default ${AUDIO_SCORE_CHANNEL_MULTIPLIER})
      --audio-score-surround N   Bonus if ch>=6 (default ${AUDIO_SCORE_SURROUND_BONUS})
      --audio-score-lang N       Language bonus (default ${AUDIO_SCORE_LANG_BONUS_ENG})
  -j, --parallelize              Encode audio tasks in parallel

Audio transcode:
      --stereo-bitrate RATE      AAC stereo bitrate (default ${STEREO_BITRATE})
      --max-audio-channels N     Cap output channels (default ${MAX_AUDIO_CHANNELS})
      --stereo-fallback          Add AAC stereo when primary >2ch (default on)
      --no-stereo-fallback       Disable AAC stereo add
      --aac-surround-5-1 RATE    AAC 5.1 bitrate (default ${AAC_SURROUND_BITRATE_5_1})
      --aac-surround-7-1 RATE    AAC 7.1 bitrate (default ${AAC_SURROUND_BITRATE_7_1})

Mux / output:
      --output-ext EXT           mp4|m4v|mov (default ${OUTPUT_EXT})
      --mp4-interleave-ms N      MP4Box -inter (default ${MP4_INTERLEAVE_MS})
      --tag-language-default L   Default tag lang if missing (default ${TAG_LANGUAGE_DEFAULT})
      --include-audio-titles     Include source title in MP4 (default on)
      --no-include-audio-titles  Do not include audio titles
      --mp4box-quiet             MP4Box -quiet (default on)
      --mp4box-verbose           Disable -quiet
EOF
}

print_version(){ echo "${APP_NAME} v${VERSION} (${CLI_NAME})"; }

do_install(){
  local INSTALL_DIR="$HOME/.bin"
  local target="$INSTALL_DIR/${CLI_NAME}"
  local self conf_path SHELL_RC added_path=0

  self="$(realpath_fallback "$0")"

  # 1) Create ~/.bin if needed
  mkdir -p "$INSTALL_DIR"

  # 2) Copy the script into place (avoid symlink to temp paths)
  if [[ -e "$target" && "$self" -ef "$target" ]]; then
    warn "Already installed: $target points to this script. Skipping copy."
  else
    if cp -f "$self" "$target"; then
      chmod +x "$target" || true
      note "Installed: $target"
    else
      die 11 "Failed to install to: $target"
    fi
  fi

  # 3) Ensure ~/.bin is in PATH for future sessions (cannot modify current shell)
  if [[ ":$PATH:" != *":$INSTALL_DIR:"* ]]; then
    note "$HOME/.bin is not currently in PATH — adding it for future sessions."

    # Pick shell rc file
    case "$SHELL" in
      */zsh)  SHELL_RC="$HOME/.zshrc" ;;
      */bash) SHELL_RC="$HOME/.bashrc" ;;
      */fish) SHELL_RC="$HOME/.config/fish/config.fish" ;;
      *)      SHELL_RC="$HOME/.profile" ;;
    esac

    # Append only if the exact line isn't already present
    if [[ "$SHELL" == *fish ]]; then
      # fish syntax
      if ! grep -qsF "set -gx PATH \$HOME/.bin \$PATH" "$SHELL_RC" 2>/dev/null; then
        mkdir -p "$(dirname "$SHELL_RC")" 2>/dev/null || true
        echo "set -gx PATH \$HOME/.bin \$PATH" >> "$SHELL_RC"
        added_path=1
      fi
    else
      # POSIX shells (bash/zsh/sh)
      if ! grep -qsF "export PATH=\"\$HOME/.bin:\$PATH\"" "$SHELL_RC" 2>/dev/null; then
        cat <<-'EOF' >> "$SHELL_RC"
	export PATH="$HOME/.bin:$PATH"
EOF
        added_path=1
      fi
    fi

    if (( added_path )); then
      note "Added \$HOME/.bin to PATH in: $SHELL_RC"
      note "Reload your shell (e.g., run: source \"$SHELL_RC\") to use '${CLI_NAME}' immediately."
    else
      note "PATH update already present in: $SHELL_RC"
    fi
  else
    note "$HOME/.bin already in PATH."
  fi

  # 4) Write default config (prompt/backup handled inside _write_default_muxmrc)
  if [[ "$EUID" -eq 0 ]]; then
    conf_path="/etc/.muxmrc"
  else
    conf_path="$HOME/.muxmrc"
  fi
  _write_default_muxmrc "$conf_path"

  note "You can also place a project-local override at ./\.muxmrc"
  exit 0
}

# ------------- Parse CLI -------------
is_valid_preset(){ case "$1" in ultrafast|superfast|veryfast|faster|fast|medium|slow|slower|veryslow|placebo) return 0;; *) return 1;; esac; }

POSITIONALS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) print_usage; exit 0 ;;
    -V|--version) print_version; exit 0 ;;
    --install) do_install ;;
    --print-effective-config) PRINT_EFFCONF=1; shift ;;
    --config)
      # Optional path argument; defaults to ./.muxmrc
      if [[ -n "${2:-}" && ! "$2" =~ ^- ]]; then
        CONFIG_WRITE_PATH="$2"
        shift 2
      else
        CONFIG_WRITE_PATH="./.muxmrc"
        shift
      fi
      CONFIG_WRITE_ROTATE=1
      ;;

    --dry-run) DRY_RUN=1; shift ;;
    --checksum) CHECKSUM=1; shift ;;
    --no-checksum) CHECKSUM=0; shift ;;
    -k|--keep-temp) KEEP_TEMP=1; shift ;;
    -K|--keep-temp-always) KEEP_TEMP_ALWAYS=1; shift ;;
    --disk-free-warn-gb) DISK_FREE_WARN_GB="${2:-}"; shift 2 ;;

    --ffmpeg-loglevel) FFMPEG_LOGLEVEL="${2:-}"; shift 2 ;;
    --no-hide-banner) FFMPEG_HIDE_BANNER=0; shift ;;
    --no-overwrite) FFMPEG_OVERWRITE=0; shift ;;
    --ffprobe-loglevel) FFPROBE_LOGLEVEL="${2:-}"; shift 2 ;;

    --threads) THREADS="${2:-}"; shift 2 ;;

    -p|--preset) PRESET_VALUE="${2:-}"; is_valid_preset "$PRESET_VALUE" || die 11 "Invalid preset: $PRESET_VALUE"; shift 2 ;;
    --crf) CRF_VALUE="${2:-}"; shift 2 ;;
    --x265-params) X265_PARAMS_BASE="${2:-}"; shift 2 ;;
    -l|--level) LEVEL_VALUE="${2:-}"; shift 2 ;;
    --no-conservative-vbv) CONSERVATIVE_VBV=0; shift ;;

    --force-420) FORCE_CHROMA_420=1; shift ;;
    --no-force-420) FORCE_CHROMA_420=0; shift ;;
    --sdr-10bit-if-src) SDR_USE_10BIT_IF_SRC_10BIT=1; shift ;;
    --no-sdr-10bit-if-src) SDR_USE_10BIT_IF_SRC_10BIT=0; shift ;;
    --hdr-target-pixfmt) HDR_TARGET_PIXFMT="${2:-}"; shift 2 ;;

    --nvenc) USE_NVENC=1; shift ;;
    --no-nvenc) USE_NVENC=0; shift ;;
    --nvenc-preset) NVENC_PRESET="${2:-}"; shift 2 ;;
    --nvenc-cq) NVENC_CQ="${2:-}"; shift 2 ;;
    --nvenc-gpu) NVENC_GPU_INDEX="${2:-}"; shift 2 ;;

    --audio-track) AUDIO_TRACK_OVERRIDE="${2:-}"; shift 2 ;;
    --audio-lang-pref) AUDIO_LANG_PREF="${2:-}"; shift 2 ;;
    --audio-codec-pref) AUDIO_CODEC_PREFERENCE="${2:-}"; shift 2 ;;
    --audio-score-chan-mul) AUDIO_SCORE_CHANNEL_MULTIPLIER="${2:-}"; shift 2 ;;
    --audio-score-surround) AUDIO_SCORE_SURROUND_BONUS="${2:-}"; shift 2 ;;
    --audio-score-lang) AUDIO_SCORE_LANG_BONUS_ENG="${2:-}"; shift 2 ;;
    -j|--parallelize) PARALLEL_AUDIO=1; shift ;;

    --stereo-bitrate) STEREO_BITRATE="${2:-}"; shift 2 ;;
    --max-audio-channels) MAX_AUDIO_CHANNELS="${2:-}"; shift 2 ;;
    --stereo-fallback) ADD_STEREO_IF_MULTICH=1; shift ;;
    --no-stereo-fallback) ADD_STEREO_IF_MULTICH=0; shift ;;
    --aac-surround-5-1) AAC_SURROUND_BITRATE_5_1="${2:-}"; shift 2 ;;
    --aac-surround-7-1) AAC_SURROUND_BITRATE_7_1="${2:-}"; shift 2 ;;

    --output-ext) OUTPUT_EXT="${2:-}"; shift 2 ;;
    --mp4-interleave-ms) MP4_INTERLEAVE_MS="${2:-}"; shift 2 ;;
    --tag-language-default) TAG_LANGUAGE_DEFAULT="${2:-}"; shift 2 ;;
    --include-audio-titles) INCLUDE_AUDIO_TITLES=1; shift ;;
    --no-include-audio-titles) INCLUDE_AUDIO_TITLES=0; shift ;;
    --mp4box-quiet) MP4BOX_QUIET=1; shift ;;
    --mp4box-verbose) MP4BOX_QUIET=0; shift ;;

    --) shift; break ;;
    -*) die 11 "Unknown option: $1. $USAGE_SHORT" ;;
    *) POSITIONALS+=("$1"); shift ;;
  esac
done

# ---------- Effective config printer ----------
print_effective_config() {
  echo "=== ${APP_NAME} v${VERSION} — Effective Config ==="
  if [[ ${#MUXM_CONFIG_LOADED[@]} -gt 0 ]]; then
    echo "Loaded config layers: ${MUXM_CONFIG_LOADED[*]}"
  else
    echo "Loaded config layers: (none)"
  fi
  cat <<EOC
# Precedence: Defaults → /etc/.muxmrc → ~/.muxmrc → ./.muxmrc → CLI flags

# Video
CRF_VALUE=${CRF_VALUE}
PRESET_VALUE=${PRESET_VALUE}
X265_PARAMS_BASE=${X265_PARAMS_BASE}
LEVEL_VALUE=${LEVEL_VALUE}
CONSERVATIVE_VBV=${CONSERVATIVE_VBV}
LEVEL_VBV_4_1_MAXRATE=${LEVEL_VBV_4_1_MAXRATE}
LEVEL_VBV_4_1_BUFSIZE=${LEVEL_VBV_4_1_BUFSIZE}
LEVEL_VBV_5_0_MAXRATE=${LEVEL_VBV_5_0_MAXRATE}
LEVEL_VBV_5_0_BUFSIZE=${LEVEL_VBV_5_0_BUFSIZE}
LEVEL_VBV_5_1_MAXRATE=${LEVEL_VBV_5_1_MAXRATE}
LEVEL_VBV_5_1_BUFSIZE=${LEVEL_VBV_5_1_BUFSIZE}
LEVEL_VBV_5_2_MAXRATE=${LEVEL_VBV_5_2_MAXRATE}
LEVEL_VBV_5_2_BUFSIZE=${LEVEL_VBV_5_2_BUFSIZE}

# Pixel/Chroma
FORCE_CHROMA_420=${FORCE_CHROMA_420}
SDR_USE_10BIT_IF_SRC_10BIT=${SDR_USE_10BIT_IF_SRC_10BIT}
HDR_TARGET_PIXFMT=${HDR_TARGET_PIXFMT}

# Threads
THREADS=${THREADS}

# Video passthrough / NVENC
VIDEO_PASSTHROUGH=${VIDEO_PASSTHROUGH}
USE_NVENC=${USE_NVENC}
NVENC_PRESET=${NVENC_PRESET}
NVENC_CQ=${NVENC_CQ}
NVENC_GPU_INDEX=${NVENC_GPU_INDEX}

# Audio selection
AUDIO_LANG_PREF=${AUDIO_LANG_PREF}
AUDIO_CODEC_PREFERENCE=${AUDIO_CODEC_PREFERENCE}
AUDIO_SCORE_CHANNEL_MULTIPLIER=${AUDIO_SCORE_CHANNEL_MULTIPLIER}
AUDIO_SCORE_SURROUND_BONUS=${AUDIO_SCORE_SURROUND_BONUS}
AUDIO_SCORE_LANG_BONUS_ENG=${AUDIO_SCORE_LANG_BONUS_ENG}

# Audio transcode
STEREO_BITRATE=${STEREO_BITRATE}
MAX_AUDIO_CHANNELS=${MAX_AUDIO_CHANNELS}
ADD_STEREO_IF_MULTICH=${ADD_STEREO_IF_MULTICH}
AAC_SURROUND_BITRATE_5_1=${AAC_SURROUND_BITRATE_5_1}
AAC_SURROUND_BITRATE_7_1=${AAC_SURROUND_BITRATE_7_1}
PARALLEL_AUDIO=${PARALLEL_AUDIO}

# Mux / output
OUTPUT_EXT=${OUTPUT_EXT}
MP4_INTERLEAVE_MS=${MP4_INTERLEAVE_MS}
TAG_LANGUAGE_DEFAULT=${TAG_LANGUAGE_DEFAULT}
INCLUDE_AUDIO_TITLES=${INCLUDE_AUDIO_TITLES}
MP4BOX_QUIET=${MP4BOX_QUIET}

# Operational
CHECKSUM=${CHECKSUM}
DRY_RUN=${DRY_RUN}
KEEP_TEMP=${KEEP_TEMP}
KEEP_TEMP_ALWAYS=${KEEP_TEMP_ALWAYS}
DISK_FREE_WARN_GB=${DISK_FREE_WARN_GB}

# ffmpeg/ffprobe UX
FFMPEG_HIDE_BANNER=${FFMPEG_HIDE_BANNER}
FFMPEG_LOGLEVEL=${FFMPEG_LOGLEVEL}
FFMPEG_OVERWRITE=${FFMPEG_OVERWRITE}
FFPROBE_LOGLEVEL=${FFPROBE_LOGLEVEL}

# Demux
ANNEXB_FOR_DEMUX=${ANNEXB_FOR_DEMUX}
EOC
}

# ---------- Write current effective config to a .muxmrc ----------
write_effective_muxmrc() {
  local out="$1"
  local ts dir name rotated

  ts="$(date +%Y%m%d-%H%M%S)"
  dir="$(dirname -- "$out")"
  name="$(basename -- "$out")"

  umask 022

  # If the target exists, rotate it first:
  if [[ -e "$out" ]]; then
    # For dotfiles like ".muxmrc", make ".effective-TS.muxmrc"
    # For normal files like "config", make "effective-TS.config"
    if [[ "$name" == .* ]]; then
      rotated="${dir}/.effective-${ts}.${name#.}"
    else
      rotated="${dir}/effective-${ts}.${name}"
    fi

    if mv -f -- "$out" "$rotated"; then
      note "Existing config moved → $rotated"
    else
      warn "Could not move existing config; continuing to write a new one."
    fi
  fi

  # Now write the new effective config to the original path
  cat >"$out" <<EORC
# =============================================================================
#  MuxMaster .muxmrc — generated $(date)
# -----------------------------------------------------------------------------
# Precedence at runtime (lowest → highest):
#   1) Script defaults
#   2) /etc/.muxmrc
#   3) \$HOME/.muxmrc
#   4) ./.muxmrc (project-local)
#   5) CLI flags
#
# This file captures the *effective* values right now, suitable as a project
# starter config. Edit as needed; comment any line to fall back to lower layers.
# =============================================================================

# ------- Video -------
CRF_VALUE=${CRF_VALUE}
PRESET_VALUE=${PRESET_VALUE}
X265_PARAMS_BASE=${X265_PARAMS_BASE}
LEVEL_VALUE=${LEVEL_VALUE}
CONSERVATIVE_VBV=${CONSERVATIVE_VBV}
LEVEL_VBV_4_1_MAXRATE=${LEVEL_VBV_4_1_MAXRATE}
LEVEL_VBV_4_1_BUFSIZE=${LEVEL_VBV_4_1_BUFSIZE}
LEVEL_VBV_5_0_MAXRATE=${LEVEL_VBV_5_0_MAXRATE}
LEVEL_VBV_5_0_BUFSIZE=${LEVEL_VBV_5_0_BUFSIZE}
LEVEL_VBV_5_1_MAXRATE=${LEVEL_VBV_5_1_MAXRATE}
LEVEL_VBV_5_1_BUFSIZE=${LEVEL_VBV_5_1_BUFSIZE}
LEVEL_VBV_5_2_MAXRATE=${LEVEL_VBV_5_2_MAXRATE}
LEVEL_VBV_5_2_BUFSIZE=${LEVEL_VBV_5_2_BUFSIZE}

# ------- Pixel/Chroma -------
FORCE_CHROMA_420=${FORCE_CHROMA_420}
SDR_USE_10BIT_IF_SRC_10BIT=${SDR_USE_10BIT_IF_SRC_10BIT}
HDR_TARGET_PIXFMT=${HDR_TARGET_PIXFMT}

# ------- Threads -------
THREADS=${THREADS}

# ------- Video passthrough / NVENC -------
VIDEO_PASSTHROUGH=${VIDEO_PASSTHROUGH}
USE_NVENC=${USE_NVENC}
NVENC_PRESET=${NVENC_PRESET}
NVENC_CQ=${NVENC_CQ}
NVENC_GPU_INDEX=${NVENC_GPU_INDEX}

# ------- Audio selection -------
AUDIO_LANG_PREF=${AUDIO_LANG_PREF}
AUDIO_CODEC_PREFERENCE=${AUDIO_CODEC_PREFERENCE}
AUDIO_SCORE_CHANNEL_MULTIPLIER=${AUDIO_SCORE_CHANNEL_MULTIPLIER}
AUDIO_SCORE_SURROUND_BONUS=${AUDIO_SCORE_SURROUND_BONUS}
AUDIO_SCORE_LANG_BONUS_ENG=${AUDIO_SCORE_LANG_BONUS_ENG}

# ------- Audio transcode -------
STEREO_BITRATE=${STEREO_BITRATE}
MAX_AUDIO_CHANNELS=${MAX_AUDIO_CHANNELS}
ADD_STEREO_IF_MULTICH=${ADD_STEREO_IF_MULTICH}
AAC_SURROUND_BITRATE_5_1=${AAC_SURROUND_BITRATE_5_1}
AAC_SURROUND_BITRATE_7_1=${AAC_SURROUND_BITRATE_7_1}
PARALLEL_AUDIO=${PARALLEL_AUDIO}

# ------- Mux / output -------
OUTPUT_EXT=${OUTPUT_EXT}
MP4_INTERLEAVE_MS=${MP4_INTERLEAVE_MS}
TAG_LANGUAGE_DEFAULT=${TAG_LANGUAGE_DEFAULT}
INCLUDE_AUDIO_TITLES=${INCLUDE_AUDIO_TITLES}
MP4BOX_QUIET=${MP4BOX_QUIET}

# ------- Operational -------
CHECKSUM=${CHECKSUM}
DRY_RUN=${DRY_RUN}
KEEP_TEMP=${KEEP_TEMP}
KEEP_TEMP_ALWAYS=${KEEP_TEMP_ALWAYS}
DISK_FREE_WARN_GB=${DISK_FREE_WARN_GB}

# ------- ffmpeg/ffprobe UX -------
FFMPEG_HIDE_BANNER=${FFMPEG_HIDE_BANNER}
FFMPEG_LOGLEVEL=${FFMPEG_LOGLEVEL}
FFMPEG_OVERWRITE=${FFMPEG_OVERWRITE}
FFPROBE_LOGLEVEL=${FFPROBE_LOGLEVEL}

# ------- Demux policy -------
ANNEXB_FOR_DEMUX=${ANNEXB_FOR_DEMUX}
EORC

  chmod 0644 "$out" || true
  note "Wrote effective config → $out"
}

# Write the effective config, but prompt & back up like --install (unused path for now)
_write_effective_muxmrc_prompted() {
  local conf_path="$1"

  if [[ ! -e "$conf_path" ]]; then
    write_effective_muxmrc "$conf_path"
    return 0
  fi

  say "Config already exists at: $conf_path"
  printf "Overwrite with effective config and back up the current file? [y/N]: " >&2
  local ans; if ! read -r ans; then ans=""; fi
  case "$ans" in
    [Yy]|[Yy][Ee][Ss])
      local ts backup_dir backup_path
      ts="$(date +%Y%m%d-%H%M%S)"
      backup_dir="$(dirname -- "$conf_path")"
      backup_path="${backup_dir}/muxmrc.${ts}.bak"
      if cp -f -- "$conf_path" "$backup_path"; then
        note "Backed up current config → $backup_path"
      else
        warn "Could not back up existing config; proceeding with overwrite."
      fi
      write_effective_muxmrc "$conf_path"
      note "Overwrote config with effective values → $conf_path"
      ;;
    *)
      note "Keeping existing config. No changes made."
      ;;
  esac
}

if (( CONFIG_WRITE_PROMPTED )); then
  _write_effective_muxmrc_prompted "$CONFIG_WRITE_PATH"
  exit 0
fi

# If user only wants to print effective config, do that and exit (no tool requirements)
if (( PRINT_EFFCONF )); then
  print_effective_config
  exit 0
fi

# If user requested to write a project config (rotate if exists), do that and exit
if (( CONFIG_WRITE_ROTATE )); then
  write_effective_muxmrc "$CONFIG_WRITE_PATH"
  exit 0
fi

# ---------- Required tools (only needed for real work) ----------
need ffmpeg
need ffprobe
need MP4Box

# ---------- Inputs ----------
FFMPEG_FLAGS=()
FFPROBE_FLAGS=()

SRC="${POSITIONALS[0]:-}"
OUT="${POSITIONALS[1]:-}"
(( ${#POSITIONALS[@]} > 2 )) && die 11 "Too many arguments. $USAGE_SHORT"
[[ -z "$SRC" ]] && { print_usage; exit 0; }
SRC_ABS="$(realpath_fallback "$SRC")"; [[ -f "$SRC_ABS" ]] || die 11 "Source not found: $SRC_ABS"

# Default OUT with overridable extension
if [[ -z ${OUT-} ]]; then
  base="${SRC_ABS%.*}"
  OUT="${base}.${OUTPUT_EXT}"
fi
OUT_DIR="$(dirname -- "$OUT")"
OUT_DIR="$(cd -- "$OUT_DIR" 2>/dev/null && pwd || echo "$OUT_DIR")"
OUT_BASENAME="$(basename -- "$OUT")"
OUT_ABS="${OUT_DIR}/${OUT_BASENAME}"
OUT="$OUT_ABS"
TMP_OUT="${OUT}.tmp"

# ---------- Build ffmpeg/ffprobe flags from effective settings ----------
(( FFMPEG_HIDE_BANNER )) && FFMPEG_FLAGS+=(-hide_banner)
FFMPEG_FLAGS+=(-loglevel "$FFMPEG_LOGLEVEL")
(( FFMPEG_OVERWRITE )) && FFMPEG_FLAGS+=(-y)
FFPROBE_FLAGS=(-v "$FFPROBE_LOGLEVEL")

# ---------- Workdir ----------
WORKDIR="$(
  TMPDIR="$OUT_DIR" mktemp -d ".muxm.tmp.XXXXXXXX"
)" || die 11 "Cannot create working directory under: $OUT_DIR"
LOGFILE="$WORKDIR/muxm.$(date +%Y%m%d-%H%M%S).log"

# ---------- Begin logging to file (tee) ----------
if [[ "${DEBUG:-0}" != "1" ]]; then
  exec > >(tee -a "$LOGFILE") 2>&1
  note "Logging to $LOGFILE"
fi

# ---------- Traps ----------
trap 'on_error $LINENO "$BASH_COMMAND" "$?"' ERR
trap 'FAILED=1; EXIT_CODE=130; FAIL_MSG="Interrupted by user (SIGINT)"; exit 130' INT
trap 'FAILED=1; EXIT_CODE=143; FAIL_MSG="Terminated (SIGTERM)"; exit 143' TERM
on_exit() {
  local have_result=0
  # In DRY-RUN we don't create real outputs; treat as success.
  if (( DRY_RUN )); then
    have_result=1
  elif [[ -n "${TMP_OUT:-}" && -s "$TMP_OUT" ]]; then
    have_result=1
  elif [[ -n "${OUT:-}" && -s "$OUT" ]]; then
    have_result=1
  fi

  if (( FAILED == 0 && have_result == 1 )); then
    if (( DRY_RUN )); then
      note "DRY-RUN complete — no files were created."
    else
      [[ -f "$TMP_OUT" ]] && mv -f "$TMP_OUT" "$OUT"
      (( CHECKSUM )) && write_checksum "$OUT"
      note "Build SUCCEEDED."
    fi
    if [[ ${#COMPLETED_STEPS[@]} -gt 0 ]]; then
      echo "---- Completed steps ----"
      for s in "${COMPLETED_STEPS[@]}"; do echo "  • $s"; done
    fi
    local _suffix=""
    (( DRY_RUN )) && _suffix=".dryrun"
    { echo "Completed: $(timestamp)"; printf "%s\n" "${COMPLETED_STEPS[@]:-}"; } \
      > "${OUT_DIR}/$(basename "${OUT}")${_suffix}.log" 2>/dev/null || true

    if [[ -n "$WORKDIR" && -d "$WORKDIR" && "${DEBUG:-0}" != "1" && $KEEP_TEMP_ALWAYS -eq 0 ]]; then
      rm -rf "$WORKDIR"
    else
      note "Keeping workdir: $WORKDIR"
    fi
    exit 0
  else
    [[ -z "$FAIL_MSG" ]] && FAIL_MSG="No output produced (likely earlier parse/runtime error)."
    printf "❌ Build FAILED. %s\n" "$FAIL_MSG"
    if [[ ${#COMPLETED_STEPS[@]} -gt 0 ]]; then
      echo "---- Completed steps ----"
      for s in "${COMPLETED_STEPS[@]}"; do echo "  • $s"; done
    fi
    echo "See log: $LOGFILE"
    if [[ -n "$WORKDIR" && -d "$WORKDIR" && "${DEBUG:-0}" != "1" && $KEEP_TEMP -eq 0 && $KEEP_TEMP_ALWAYS -eq 0 ]]; then
      rm -rf "$WORKDIR"
    else
      note "Keeping failure artifacts at: $WORKDIR"
    fi
    exit "${EXIT_CODE:-1}"
  fi
}
trap 'on_exit' EXIT

# ---------- Disk space preflight ----------
disk_free_warn() {
  local avail_kb
  avail_kb="$(df -k "$OUT_DIR" 2>/dev/null | awk 'NR==2{print $4}')"
  if [[ -n "$avail_kb" ]] && (( avail_kb < DISK_FREE_WARN_GB*1024*1024 )); then
    warn "Less than ~${DISK_FREE_WARN_GB}GB free on output volume ($OUT_DIR). Encode may fail."
  fi
}
disk_free_warn

# ---------- Banner ----------
say "=== ${APP_NAME} v${VERSION} — CLI: ${CLI_NAME}"
say "=== Input      : $SRC_ABS"
say "=== Output     : $OUT"
say "=== Workdir    : $WORKDIR"
say "=== Defaults   : CRF=$CRF_VALUE  StereoBitrate=$STEREO_BITRATE  Preset=$PRESET_VALUE"
(( DRY_RUN )) && note "DRY-RUN is ON"
[[ ${#MUXM_CONFIG_LOADED[@]} -gt 0 ]] && note "Config layers: ${MUXM_CONFIG_LOADED[*]}"

# ---------- ffprobe Helpers (20) ----------
# Safe, quiet field probe (first line only)
_probe_field(){
  # $1=field list for -show_entries stream=..., $2=file
  ffprobe "${FFPROBE_FLAGS[@]}" -show_entries "stream=$1" \
          -of default=nk=1:nw=1 "$2" 2>/dev/null | head -n1 || true
}

# Robust stream-type detector that won't trip -e/pipefail
_has_stream(){
  # $1=file, $2=codec_type: audio|video|subtitle|data
  local types
  types="$(ffprobe "${FFPROBE_FLAGS[@]}" -show_entries stream=codec_type \
           -of default=nk=1:nw=1 "$1" 2>/dev/null || true)"
  # Compare inside awk to keep pipeline exit 0
  printf '%s\n' "$types" | awk -v want="$2" 'BEGIN{IGNORECASE=1} $0==want{found=1} END{exit !found}'
}

# Primary video codec name (v:0), lowercase
_vcodec_name(){
  ffprobe "${FFPROBE_FLAGS[@]}" -select_streams v:0 \
          -show_entries stream=codec_name -of default=nk=1:nw=1 "$1" 2>/dev/null \
    | head -n1 | tr '[:upper:]' '[:lower:]' || true
}

# ---------- Color Space & Pixel Format Decision ----------
PROFILE_DESC="SDR"
TARGET_PIXFMT="yuv420p"
COLOR_ARGS=()

# Defaults for audio-related metadata (filled later)
A_LANG="$TAG_LANGUAGE_DEFAULT"
A_TITLE=""
AIDX=0
HAS_AUDIO=0

decide_color_and_pixfmt() {
  local src="$1" pix prim trc cspace
  pix="$(_probe_field pix_fmt "$src")"
  prim="$(_probe_field color_primaries "$src")"
  trc="$(_probe_field color_transfer "$src")"
  cspace="$(_probe_field color_space "$src")"

  prim="$(printf %s "$prim"   | tr '[:upper:]' '[:lower:]')"
  trc="$(printf %s "$trc"     | tr '[:upper:]' '[:lower:]')"
  cspace="$(printf %s "$cspace"| tr '[:upper:]' '[:lower:]')"
  pix="$(printf %s "$pix"     | tr '[:upper:]' '[:lower:]')"

  local is_10bit=0 chroma="420"
  [[ "$pix" =~ p10 ]] && is_10bit=1
  [[ "$pix" =~ 422 ]] && chroma="422"
  [[ "$pix" =~ 444 ]] && chroma="444"

  if (( FORCE_CHROMA_420 )) && [[ "$chroma" != "420" ]]; then
    warn "Source chroma is 4:${chroma}; downsampling to 4:2:0 for Apple TV Direct Play."
    chroma="420"
  fi

  local tgt_pix="yuv420p" profile="SDR"
  if [[ "$trc" == "arib-std-b67" || "$trc" == "hlg" ]]; then
    profile="HLG"; tgt_pix="$HDR_TARGET_PIXFMT"; COLOR_ARGS=(-color_primaries bt2020 -color_trc arib-std-b67 -colorspace bt2020nc)
  elif [[ "$prim" == "bt2020" || "$cspace" == "bt2020nc" || "$trc" == "smpte2084" ]]; then
    profile="HDR10"; tgt_pix="$HDR_TARGET_PIXFMT"; COLOR_ARGS=(-color_primaries bt2020 -color_trc smpte2084 -colorspace bt2020nc)
  else
    profile="SDR"
    if (( SDR_USE_10BIT_IF_SRC_10BIT )) && (( is_10bit )); then tgt_pix=yuv420p10le; else tgt_pix=yuv420p; fi
    [[ -z "$prim" ]] && prim="bt709"; [[ -z "$trc" ]] && trc="bt709"; [[ -z "$cspace" ]] && cspace="bt709"
    COLOR_ARGS=(-color_primaries "$prim" -color_trc "$trc" -colorspace "$cspace")
  fi
  PROFILE_DESC="$profile"; TARGET_PIXFMT="$tgt_pix"
}

# ---------- x265 Params & Level/VBV Guardrails (22) ----------
X265_PARAMS="$X265_PARAMS_BASE"
decide_color_and_pixfmt "$SRC_ABS"

# If we're not HDR10, ensure hdr-opt is NOT present (covers HLG and SDR).
if [[ "$PROFILE_DESC" != "HDR10" ]]; then
  X265_PARAMS="${X265_PARAMS/:hdr-opt=1/}"
fi

# If (and only if) we are HDR10, enable HDR10 signaling and set x265's colorimetry.
if [[ "$PROFILE_DESC" == "HDR10" ]]; then
  X265_PARAMS="${X265_PARAMS}:hdr10=1:hdr10-opt=1:colorprim=bt2020:transfer=smpte2084:colormatrix=bt2020nc:range=limited"
fi

apply_level_vbv() {
  local lvl="$1" maxrate="" bufsize=""
  if (( CONSERVATIVE_VBV )); then
    case "$lvl" in
      4.1) maxrate="$LEVEL_VBV_4_1_MAXRATE"; bufsize="$LEVEL_VBV_4_1_BUFSIZE" ;;
      5.0) maxrate="$LEVEL_VBV_5_0_MAXRATE"; bufsize="$LEVEL_VBV_5_0_BUFSIZE" ;;
      5.1) maxrate="$LEVEL_VBV_5_1_MAXRATE"; bufsize="$LEVEL_VBV_5_1_BUFSIZE" ;;
      5.2) maxrate="$LEVEL_VBV_5_2_MAXRATE"; bufsize="$LEVEL_VBV_5_2_BUFSIZE" ;;
    esac
  fi
  if [[ -n "$maxrate" ]]; then
    X265_PARAMS="${X265_PARAMS}:level-idc=${lvl}:vbv-maxrate=${maxrate}:vbv-bufsize=${bufsize}"
    note "Applying VBV guardrails for level ${lvl} → maxrate=${maxrate}, bufsize=${bufsize}"
  else
    [[ -n "$lvl" ]] && X265_PARAMS="${X265_PARAMS}:level-idc=${lvl}"
  fi
}
[[ -n "$LEVEL_VALUE" ]] && apply_level_vbv "$LEVEL_VALUE"

# ---------- Video Passthrough & NVENC Detection ----------
# Check if video codec allows passthrough (H.264 or H.265)
_is_passthrough_codec() {
  local codec; codec="$(_vcodec_name "$1")"
  case "$codec" in
    h264|avc|avc1|h265|hevc) return 0 ;;
    *) return 1 ;;
  esac
}

# Check NVENC availability
check_nvenc_available() {
  if ! ffmpeg -hide_banner -encoders 2>/dev/null | grep -q "hevc_nvenc"; then
    warn "NVENC not available. Falling back to libx265 (CPU)."
    USE_NVENC=0
    return 1
  fi
  return 0
}

# Determine video handling strategy
decide_video_strategy() {
  local src="$1"
  SRC_VCODEC="$(_vcodec_name "$src")"

  if _is_passthrough_codec "$src"; then
    VIDEO_PASSTHROUGH=1
    note "Source video codec ($SRC_VCODEC) supports passthrough. Video will be copied."
  else
    VIDEO_PASSTHROUGH=0
    note "Source video codec ($SRC_VCODEC) requires transcoding to H.265."
    # Check NVENC availability for transcoding
    if (( USE_NVENC )); then
      check_nvenc_available || true
    fi
  fi
}

decide_video_strategy "$SRC_ABS"

# ---------- Audio Selection Utilities ----------
# Hardened helpers that never fail under -eEuo pipefail and cope with odd metadata.

# Count positional audio streams (what -map 0:a:N uses)
_audio_count() {
  local n
  n="$(ffprobe "${FFPROBE_FLAGS[@]}" -select_streams a \
        -show_entries stream=index -of csv=p=0 "$SRC_ABS" 2>/dev/null | wc -l | tr -d '[:space:]')"
  [[ -n "$n" ]] || n=0
  echo "$n"
}

# List 0..N-1
list_audio_indices(){
  local n i
  n="$(_audio_count)"
  for (( i=0; i<n; i++ )); do echo "$i"; done
}

# Safe field/tag getters (first line only)
_ap_audio_field() { # $1=idx, $2=field
  local out=""
  out="$(ffprobe "${FFPROBE_FLAGS[@]}" -select_streams "a:$1" \
         -show_entries "stream=$2" -of default=nk=1:nw=1 "$SRC_ABS" 2>/dev/null || true)"
  printf '%s\n' "${out%%$'\n'*}"
}
_ap_audio_tag() {   # $1=idx, $2=tag
  local out=""
  out="$(ffprobe "${FFPROBE_FLAGS[@]}" -select_streams "a:$1" \
         -show_entries "stream_tags=$2" -of default=nk=1:nw=1 "$SRC_ABS" 2>/dev/null || true)"
  printf '%s\n' "${out%%$'\n'*}"
}

describe_audio_stream() {
  local i="$1" codec ch layout lang title br kbps
  codec="$(_ap_audio_field "$i" codec_name | tr '[:upper:]' '[:lower:]')"
  ch="$(_ap_audio_field "$i" channels)"; [[ -z "$ch" ]] && ch="?"
  layout="$(_ap_audio_field "$i" channel_layout)"
  lang="$(_ap_audio_tag "$i" language)"; [[ -z "$lang" ]] && lang="und"
  title="$(_ap_audio_tag "$i" title)"
  br="$(_ap_audio_field "$i" bit_rate)"
  if [[ $br =~ ^[0-9]+$ && $br -gt 0 ]]; then kbps="$(( br / 1000 ))kbps"; else kbps=""; fi
  printf "#%s: %s %s%s [%s]%s%s\n" \
    "$i" "${codec:-?}" "${ch}" "${layout:+ ($layout)}" "$lang" "${title:+ — $title}" "${kbps:+, $kbps}"
}

# Codec preference ranking (lower is better)
_muxm_codec_rank(){
  local codec; codec="$(printf %s "$1" | tr '[:upper:]' '[:lower:]')"
  local IFS=, pref i=0
  for pref in $AUDIO_CODEC_PREFERENCE; do
    if [[ "$codec" == "$pref" ]]; then echo "$i"; return; fi
    ((i++))
  done
  echo "$i"
}

# Language bonus if in preferred set
_muxm_lang_bonus(){
  local lang; lang="$(printf %s "$1" | tr '[:upper:]' '[:lower:]')"
  local IFS=, pref
  for pref in $AUDIO_LANG_PREF; do
    if [[ "$lang" == "$pref" ]]; then echo "$AUDIO_SCORE_LANG_BONUS_ENG"; return; fi
  done
  echo 0
}

# Score stream: codec rank, channels, surround bonus, language
score_audio_stream() {
  local i="$1" codec ch lang score=0 rank
  codec="$(_ap_audio_field "$i" codec_name | tr '[:upper:]' '[:lower:]')"
  ch="$(_ap_audio_field "$i" channels)"; [[ -z "$ch" ]] && ch=2
  lang="$(_ap_audio_tag "$i" language | tr '[:upper:]' '[:lower:]')"
  rank="$(_muxm_codec_rank "$codec")"
  (( score += 400 - (rank*80) ))
  (( score += ch * AUDIO_SCORE_CHANNEL_MULTIPLIER ))
  (( ch >= 6 )) && (( score += AUDIO_SCORE_SURROUND_BONUS ))
  (( score += $(_muxm_lang_bonus "$lang") ))
  echo "$score"
}

# Choose best existing index (never empty)
auto_select_best_audio() {
  local idxs=() i score best_idx=0 best_score=-1
  while IFS= read -r i; do [[ -n "$i" ]] && idxs+=("$i"); done < <(list_audio_indices)
  (( ${#idxs[@]} == 0 )) && { echo 0; return; }
  for i in "${idxs[@]}"; do
    score="$(score_audio_stream "$i")"
    (( score > best_score )) && { best_score="$score"; best_idx="$i"; }
  done
  echo "$best_idx"
}

# Resolve the audio index; respect override; never return empty
resolve_audio_track_index() {
  local idxs=() i
  while IFS= read -r i; do [[ -n "$i" ]] && idxs+=("$i"); done < <(list_audio_indices)

  if [[ -n "${AUDIO_TRACK_OVERRIDE:-}" ]]; then
    [[ $AUDIO_TRACK_OVERRIDE =~ ^[0-9]+$ ]] || die 11 "--audio-track must be a non-negative integer"
    printf '%s\n' "${idxs[@]}" | grep -qx "$AUDIO_TRACK_OVERRIDE" || die 11 "Requested --audio-track $AUDIO_TRACK_OVERRIDE not found"
    echo "$AUDIO_TRACK_OVERRIDE"; return
  fi

  (( ${#idxs[@]} > 0 )) && { auto_select_best_audio; return; }
  echo 0
}

# ---------- Temp Paths ----------
V_ENCODED="$WORKDIR/video_encoded.mp4"
V_FINAL=""  # Will be set to "passthrough" or path to encoded file
A_PRIMARY=""
AAC_STEREO=""
SUB_MOV_TEXT=""
MP4_BASE="$WORKDIR/primary_base.mp4"

# ---------- Video Processing (Step [1/10]) ----------
say "[1/10] Video preparation (passthrough=$VIDEO_PASSTHROUGH, codec=$SRC_VCODEC)…"

if (( VIDEO_PASSTHROUGH )); then
  V_FINAL="passthrough"
  mark_done "Video passthrough ($SRC_VCODEC)"
else
  # Need to transcode - use NVENC or CPU
  say "[2/10] Encoding video to H.265 ($PROFILE_DESC, $TARGET_PIXFMT)…"
  if (( DRY_RUN )); then
    if (( USE_NVENC )); then
      say "DRY-RUN: NVENC encode (preset $NVENC_PRESET, cq $NVENC_CQ) → $V_ENCODED"
    else
      say "DRY-RUN: x265 encode (CRF $CRF_VALUE, preset $PRESET_VALUE) → $V_ENCODED"
    fi
    : > "$V_ENCODED"
  elif (( USE_NVENC )); then
    # NVENC hardware encode
    note "Using NVENC hardware encoding (preset=$NVENC_PRESET, cq=$NVENC_CQ)"
    local nvenc_pix="p010le"
    [[ "$TARGET_PIXFMT" == "yuv420p" ]] && nvenc_pix="yuv420p"

    ffmpeg "${FFMPEG_FLAGS[@]}" -hwaccel cuda -hwaccel_device "$NVENC_GPU_INDEX" \
      -i "$SRC_ABS" -map 0:v:0 \
      -c:v hevc_nvenc -preset "$NVENC_PRESET" -tune "$NVENC_TUNE" \
      -cq "$NVENC_CQ" -b:v 0 \
      -pix_fmt "$nvenc_pix" \
      "${COLOR_ARGS[@]}" \
      -an "$V_ENCODED"
  else
    # CPU fallback (libx265)
    note "Using CPU encoding (libx265, preset=$PRESET_VALUE, crf=$CRF_VALUE)"
    ffargs=( "${FFMPEG_FLAGS[@]}" -i "$SRC_ABS" -map 0:v:0 -c:v libx265 -preset "$PRESET_VALUE" -crf "$CRF_VALUE" -pix_fmt "$TARGET_PIXFMT" )
    [[ -n "$THREADS" ]] && ffargs+=( -threads "$THREADS" )

    if [[ "$PROFILE_DESC" == "HDR10" ]]; then
      ffmpeg "${ffargs[@]}" -x265-params "$X265_PARAMS" \
        -color_primaries bt2020 -color_trc smpte2084 -colorspace bt2020nc -color_range tv \
        -an "$V_ENCODED"
    else
      ffmpeg "${ffargs[@]}" -x265-params "$X265_PARAMS" "${COLOR_ARGS[@]}" -an "$V_ENCODED"
    fi
  fi
  V_FINAL="$V_ENCODED"
  mark_done "Encode video ($(( USE_NVENC )) && echo 'NVENC' || echo 'x265')"
fi

# ---------- Audio Presence & Index Resolve (Step [3/10]) ----------
# Use hardened detector to avoid tripping -eEuo pipefail if grep returns 1
if _has_stream "$SRC_ABS" audio; then
  HAS_AUDIO=1
else
  HAS_AUDIO=0
fi

if (( HAS_AUDIO )); then
  AIDX="$(resolve_audio_track_index)"
  # Fill metadata defensively; always provide something sane
  A_LANG="$(_ap_audio_tag "$AIDX" language)"; [[ -z "$A_LANG" ]] && A_LANG="$TAG_LANGUAGE_DEFAULT"
  A_TITLE="$(_ap_audio_tag "$AIDX" title)"
  note "[Audio Select] Using track #$AIDX: $(describe_audio_stream "$AIDX")"

  # Short debug dump to verify what we saw (non-fatal, helpful during tuning)
  say "[6b] Detected audio streams:"
  for i in $(list_audio_indices); do
    describe_audio_stream "$i" || true
  done
else
  AIDX=0
  A_LANG="$TAG_LANGUAGE_DEFAULT"
  A_TITLE=""
  note "No audio tracks detected; continuing with video-only."
fi

# ---------- Audio Formats & Temp Names (Step [4/10]) ----------
# Detect codec/channels defensively and pick temp filenames/containers.
# This fork always outputs AAC (copy if source is AAC, transcode otherwise).
ACODEC="$(ffprobe "${FFPROBE_FLAGS[@]}" -select_streams a:"$AIDX" -show_entries stream=codec_name -of default=nk=1:nw=1 "$SRC_ABS" 2>/dev/null | head -n1 | tr '[:upper:]' '[:lower:]' || true)"
ACHANNELS="$(ffprobe "${FFPROBE_FLAGS[@]}" -select_streams a:"$AIDX" -show_entries stream=channels   -of default=nk=1:nw=1 "$SRC_ABS" 2>/dev/null | head -n1 || true)"
[[ -z "$ACHANNELS" ]] && ACHANNELS=2

ADD_STEREO=0
(( ACHANNELS > 2 )) && ADD_STEREO=1

# All audio outputs use AAC in MP4/M4A container
A_PRIMARY="$WORKDIR/audio_primary.m4a"
A_PRIMARY_FMT="mp4"
AAC_STEREO="$WORKDIR/stereo.m4a"

# ---------- Audio Preparation (primary + optional stereo) (Steps [5/10]) ----------
start_aac_stereo_job() {
  # Always encode a clean AAC stereo track in MP4 container
  if [[ -n "$THREADS" ]]; then
    ffmpeg "${FFMPEG_FLAGS[@]}" -threads "$THREADS" -i "$SRC_ABS" -map 0:a:"$AIDX" \
      -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -f mp4 "$AAC_STEREO"
  else
    ffmpeg "${FFMPEG_FLAGS[@]}" -i "$SRC_ABS" -map 0:a:"$AIDX" \
      -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -f mp4 "$AAC_STEREO"
  fi
}

prepare_primary_audio_copy_or_transcode() {
  # Copy when codec is already AAC; otherwise transcode to AAC.
  # This simplified fork outputs AAC only for maximum compatibility.
  if [[ "$ACODEC" == "aac" ]]; then
    # Ensure proper MP4 framing for AAC (avoids ADTS-in-MP4 weirdness on some builds)
    ffmpeg "${FFMPEG_FLAGS[@]}" -i "$SRC_ABS" -map 0:a:"$AIDX" -c copy -movflags +faststart -f mp4 "$A_PRIMARY"
    note "AAC detected. Copying without conversion."
    return 0
  fi

  # Transcode non-AAC codecs to AAC based on channel count
  A_PRIMARY="$WORKDIR/audio_primary.m4a"; A_PRIMARY_FMT="mp4"
  if (( ACHANNELS <= 2 )); then
    if [[ -n "$THREADS" ]]; then
      ffmpeg "${FFMPEG_FLAGS[@]}" -threads "$THREADS" -i "$SRC_ABS" -map 0:a:"$AIDX" \
        -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -movflags +faststart -f mp4 "$A_PRIMARY"
    else
      ffmpeg "${FFMPEG_FLAGS[@]}" -i "$SRC_ABS" -map 0:a:"$AIDX" \
        -c:a aac -b:a "$STEREO_BITRATE" -ac 2 -movflags +faststart -f mp4 "$A_PRIMARY"
    fi
    note "Non-AAC stereo codec ($ACODEC). Transcoding to AAC $STEREO_BITRATE."
  else
    # Transcode multichannel to AAC with appropriate bitrate
    local channels_to_keep="$ACHANNELS"
    (( channels_to_keep > MAX_AUDIO_CHANNELS )) && channels_to_keep="$MAX_AUDIO_CHANNELS"
    local _aac_br
    if (( channels_to_keep >= 7 )); then _aac_br="$AAC_SURROUND_BITRATE_7_1"; else _aac_br="$AAC_SURROUND_BITRATE_5_1"; fi
    if [[ -n "$THREADS" ]]; then
      ffmpeg "${FFMPEG_FLAGS[@]}" -threads "$THREADS" -i "$SRC_ABS" -map 0:a:"$AIDX" \
        -c:a aac -b:a "$_aac_br" -ac "$channels_to_keep" -movflags +faststart -f mp4 "$A_PRIMARY"
    else
      ffmpeg "${FFMPEG_FLAGS[@]}" -i "$SRC_ABS" -map 0:a:"$AIDX" \
        -c:a aac -b:a "$_aac_br" -ac "$channels_to_keep" -movflags +faststart -f mp4 "$A_PRIMARY"
    fi
    note "Non-AAC multichannel codec ($ACODEC). Transcoding to AAC $_aac_br (${channels_to_keep}ch)."
  fi
}

if (( HAS_AUDIO )); then
  if (( PARALLEL_AUDIO )); then
    say "[5/10] Preparing primary audio (parallel) → $A_PRIMARY"
    ( prepare_primary_audio_copy_or_transcode ) & PID_PRIMARY=$!
    if (( ADD_STEREO )) && (( ADD_STEREO_IF_MULTICH )); then
      say "[5/10] Creating AAC stereo fallback (parallel) → $AAC_STEREO"
      ( start_aac_stereo_job ) & PID_STEREO=$!
    else
      : > "$AAC_STEREO"; PID_STEREO=""
    fi

    PRIMARY_STATUS=0; STEREO_STATUS=0
    [[ -n "${PID_PRIMARY:-}" ]] && { if ! wait "$PID_PRIMARY"; then PRIMARY_STATUS=$?; kill_if_running "$PID_STEREO"; fi; }
    [[ -n "${PID_STEREO:-}"  ]] && { if ! wait "$PID_STEREO";  then STEREO_STATUS=$?;  kill_if_running "$PID_PRIMARY"; fi; }
    (( PRIMARY_STATUS != 0 )) && die 30 "Primary audio job failed (exit $PRIMARY_STATUS)."
    (( ADD_STEREO == 1 && ADD_STEREO_IF_MULTICH == 1 && STEREO_STATUS != 0 )) && die 31 "Stereo fallback job failed (exit $STEREO_STATUS)."

    mark_done "Primary audio prepared (parallel)"
    (( ADD_STEREO && ADD_STEREO_IF_MULTICH )) && mark_done "Create AAC stereo (parallel)"
  else
    say "[5/10] Preparing primary audio → $A_PRIMARY"
    prepare_primary_audio_copy_or_transcode
    mark_done "Primary audio prepared"

    if (( ADD_STEREO )) && (( ADD_STEREO_IF_MULTICH )); then
      say "[5/10] Creating AAC stereo fallback → $AAC_STEREO"
      start_aac_stereo_job
      mark_done "Create AAC stereo"
    else
      note "[5/10] Primary audio is stereo (or fallback disabled); no extra stereo needed."
      : > "$AAC_STEREO"
    fi
  fi
else
  : > "$A_PRIMARY"; : > "$AAC_STEREO"
  note "No audio tracks detected; continuing with video-only."
fi

# ---------- Primary MP4 Mux (video + primary audio) (Step [7/10]) ----------
say "[7/10] Muxing primary MP4 → $MP4_BASE"
if (( DRY_RUN )); then
  say "DRY-RUN: MP4Box mux → $MP4_BASE"
  : > "$MP4_BASE"
else
  _mp4box_quiet=(); (( MP4BOX_QUIET )) && _mp4box_quiet=(-quiet)
  _title_arg=""
  (( INCLUDE_AUDIO_TITLES )) && [[ -n "$A_TITLE" ]] && _title_arg=":name=$A_TITLE"

  if [[ -s "$A_PRIMARY" ]]; then
    # Try MP4Box first for consistent interleaving
    if ! MP4Box "${_mp4box_quiet[@]}" -add "$V_MIXED" -add "$A_PRIMARY:lang=$A_LANG${_title_arg}" -inter "$MP4_INTERLEAVE_MS" -new "$MP4_BASE"; then
      warn "MP4Box failed to import audio (codec/container support). Falling back to ffmpeg for mux."
      # ffmpeg fallback mux (handles EC-3/AC-3-in-MP4 correctly)
      ffmpeg -hide_banner -loglevel "$FFMPEG_LOGLEVEL" -y \
        -i "$V_MIXED" -i "$A_PRIMARY" \
        -map 0:v:0 -map 1:a:0 -c copy -movflags +faststart "$MP4_BASE"
    fi
  else
    # Video-only
    if ! MP4Box "${_mp4box_quiet[@]}" -add "$V_MIXED" -inter "$MP4_INTERLEAVE_MS" -new "$MP4_BASE"; then
      ffmpeg -hide_banner -loglevel "$FFMPEG_LOGLEVEL" -y \
        -i "$V_MIXED" -map 0:v:0 -c copy -movflags +faststart "$MP4_BASE"
    fi
  fi
fi
mark_done "Mux primary"

# ---------- Final Assembly (add stereo or copy base) (Step [8/10]) ----------
say "[8/10] Assembling final MP4 → $TMP_OUT"
if (( DRY_RUN )); then
  say "DRY-RUN: finalize → $TMP_OUT"
  : > "$TMP_OUT"
else
  _mp4box_quiet=(); (( MP4BOX_QUIET )) && _mp4box_quiet=(-quiet)
  if [[ -s "$AAC_STEREO" ]]; then
    # Try MP4Box to append the stereo track with language + title
    if ! MP4Box "${_mp4box_quiet[@]}" -add "$MP4_BASE" -add "$AAC_STEREO:name=Stereo:lang=$A_LANG" -inter "$MP4_INTERLEAVE_MS" -new "$TMP_OUT"; then
      warn "MP4Box failed to append stereo track. Falling back to ffmpeg."
      ffmpeg -hide_banner -loglevel "$FFMPEG_LOGLEVEL" -y \
        -i "$MP4_BASE" -i "$AAC_STEREO" \
        -map 0 -map 1:a:0 -c copy -movflags +faststart "$TMP_OUT"
    fi
  else
    cp -f "$MP4_BASE" "$TMP_OUT"
  fi
  [[ ! -s "$TMP_OUT" ]] && die 40 "Final temp output not created or empty: $TMP_OUT"
fi
mark_done "Finalize MP4"

# ---------- Verification (Step [9/10]) ----------
say "[9/10] Verifying streams…"
if (( DRY_RUN )); then
  say "DRY-RUN: ffprobe verify $TMP_OUT"
else
  ffprobe -hide_banner -show_streams "$TMP_OUT" | sed -n '1,160p' || true
fi
mark_done "Verify output"

# ---------- Output Size (Step [10/10]) ----------
say "[10/10] Output (temp) size:"
if (( DRY_RUN )); then
  say "DRY-RUN: size of $TMP_OUT"
else
  filesize_pretty "$TMP_OUT"
fi

# ---------- Finalize/Mv Happens in EXIT Trap ----------
note "✅ Staging complete — will atomically move to: $OUT"