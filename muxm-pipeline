#!/usr/bin/env bash
# =============================================================================
#  muxm-pipeline - High-performance batch processor with local caching
#  Optimized for NFS sources with local NVMe processing
# =============================================================================

set -euo pipefail

# ---------- Defaults ----------
CACHE_DIR="${CACHE_DIR:-/var/cache/muxm}"
CACHE_INPUT="$CACHE_DIR/input"
CACHE_OUTPUT="$CACHE_DIR/output"
CACHE_TEMP="$CACHE_DIR/temp"

MAX_WORKERS="${MAX_WORKERS:-6}"
PREFETCH_COUNT="${PREFETCH_COUNT:-3}"        # Files to prefetch ahead
CACHE_MAX_GB="${CACHE_MAX_GB:-1800}"         # Max cache usage in GB
RECURSIVE="${RECURSIVE:-1}"
FILE_EXTENSIONS="${FILE_EXTENSIONS:-mkv,mp4,avi,mov,m4v,ts,wmv,webm,flv}"

# Naming - always update codec tags to reflect actual output format

# Safety
DELETE_ORIGINAL="${DELETE_ORIGINAL:-0}"      # Set to 1 to enable (dangerous!)
VERIFY_OUTPUT="${VERIFY_OUTPUT:-1}"          # Verify before deleting original

# Filebot integration (optional)
USE_FILEBOT="${USE_FILEBOT:-0}"              # Enable filebot renaming
FILEBOT_DB="${FILEBOT_DB:-TheMovieDB::TV}"   # Default: TV shows from TMDB
FILEBOT_FORMAT="${FILEBOT_FORMAT:-}"         # Custom format string (empty = use default)
FILEBOT_ACTION="${FILEBOT_ACTION:-move}"     # move, copy, hardlink, symlink
FILEBOT_CONFLICT="${FILEBOT_CONFLICT:-auto}" # skip, override, auto, index, fail
FILEBOT_LANG="${FILEBOT_LANG:-en}"           # Language for metadata
FILEBOT_BIN=""                               # Filebot binary path (auto-detected)

DRY_RUN=0
VERBOSE=0
MONITOR_UI="${MONITOR_UI:-1}"                 # Enable TUI monitoring (default: on)

# ---------- Colors ----------
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
NC='\033[0m'
BOLD='\033[1m'
DIM='\033[2m'

# TUI Colors
BG_BLACK='\033[40m'
BG_GRAY='\033[48;5;236m'
BG_DARK='\033[48;5;234m'

# ---------- Status Directory ----------
STATUS_DIR=""
START_TIME=""
COMPLETED_COUNT=0
FAILED_COUNT=0
TOTAL_FILES=0

# ---------- Helpers ----------
say()  { echo -e "${BLUE}[pipeline]${NC} $*"; }
note() { echo -e "${GREEN}[pipeline]${NC} $*"; }
warn() { echo -e "${YELLOW}[pipeline]${NC} $*" >&2; }
die()  { echo -e "${RED}[pipeline]${NC} $*" >&2; exit 1; }
debug() { (( VERBOSE )) && echo -e "${CYAN}[debug]${NC} $*"; }

# ---------- System Monitoring ----------
# Get CPU usage percentage
get_cpu_usage() {
  # Read /proc/stat twice with small delay
  local cpu1 cpu2
  read -r cpu1 < <(head -1 /proc/stat)
  sleep 0.1
  read -r cpu2 < <(head -1 /proc/stat)

  # Parse values: cpu user nice system idle iowait irq softirq
  local -a v1 v2
  read -ra v1 <<< "$cpu1"
  read -ra v2 <<< "$cpu2"

  # Calculate delta
  local idle1=$((v1[4] + v1[5]))
  local idle2=$((v2[4] + v2[5]))
  local total1=$((v1[1] + v1[2] + v1[3] + v1[4] + v1[5] + v1[6] + v1[7]))
  local total2=$((v2[1] + v2[2] + v2[3] + v2[4] + v2[5] + v2[6] + v2[7]))

  local idle_delta=$((idle2 - idle1))
  local total_delta=$((total2 - total1))

  if (( total_delta > 0 )); then
    echo $(( (total_delta - idle_delta) * 100 / total_delta ))
  else
    echo 0
  fi
}

# Get RAM usage
get_ram_usage() {
  local total available
  total=$(grep MemTotal /proc/meminfo | awk '{print $2}')
  available=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
  local used=$((total - available))
  local percent=$((used * 100 / total))
  local used_gb=$((used / 1024 / 1024))
  local total_gb=$((total / 1024 / 1024))
  echo "$percent $used_gb $total_gb"
}

# Get GPU usage (NVIDIA)
get_gpu_usage() {
  if command -v nvidia-smi &>/dev/null; then
    nvidia-smi --query-gpu=utilization.gpu,memory.used,memory.total --format=csv,noheader,nounits 2>/dev/null | head -1 | tr -d ' '
  else
    echo "N/A"
  fi
}

# Format duration from seconds
format_duration() {
  local secs=$1
  printf "%02d:%02d:%02d" $((secs/3600)) $(((secs%3600)/60)) $((secs%60))
}

# ---------- Worker Status Functions ----------
init_status_dir() {
  STATUS_DIR=$(mktemp -d)
  mkdir -p "$STATUS_DIR/workers"
  mkdir -p "$STATUS_DIR/recent"
  echo "0" > "$STATUS_DIR/completed"
  echo "0" > "$STATUS_DIR/failed"
  echo "0" > "$STATUS_DIR/skipped"
  START_TIME=$(date +%s)
}

cleanup_status_dir() {
  [[ -n "$STATUS_DIR" && -d "$STATUS_DIR" ]] && rm -rf "$STATUS_DIR"
}

# Update worker status
# Args: worker_id state filename step progress
update_worker_status() {
  local worker_id="$1"
  local state="$2"
  local filename="$3"
  local step="${4:-}"
  local progress="${5:-0}"

  [[ -z "$STATUS_DIR" ]] && return

  cat > "$STATUS_DIR/workers/$worker_id" <<EOF
state=$state
filename=$filename
step=$step
progress=$progress
timestamp=$(date +%s)
EOF
}

# Clear worker status (when done)
clear_worker_status() {
  local worker_id="$1"
  [[ -z "$STATUS_DIR" ]] && return
  rm -f "$STATUS_DIR/workers/$worker_id"
}

# Add to recent completions
add_recent() {
  local status="$1"  # success or failed
  local filename="$2"
  [[ -z "$STATUS_DIR" ]] && return
  echo "$status:$filename:$(date +%s)" >> "$STATUS_DIR/recent/log"
  # Keep only last 10
  tail -10 "$STATUS_DIR/recent/log" > "$STATUS_DIR/recent/log.tmp" 2>/dev/null || true
  mv "$STATUS_DIR/recent/log.tmp" "$STATUS_DIR/recent/log" 2>/dev/null || true
}

# Increment counters
increment_completed() {
  [[ -z "$STATUS_DIR" ]] && return
  local count
  count=$(cat "$STATUS_DIR/completed" 2>/dev/null || echo 0)
  echo $((count + 1)) > "$STATUS_DIR/completed"
}

increment_failed() {
  [[ -z "$STATUS_DIR" ]] && return
  local count
  count=$(cat "$STATUS_DIR/failed" 2>/dev/null || echo 0)
  echo $((count + 1)) > "$STATUS_DIR/failed"
}

increment_skipped() {
  [[ -z "$STATUS_DIR" ]] && return
  local count
  count=$(cat "$STATUS_DIR/skipped" 2>/dev/null || echo 0)
  echo $((count + 1)) > "$STATUS_DIR/skipped"
}

# ---------- TUI Drawing Functions ----------
# Move cursor to position
cursor_to() { printf '\033[%d;%dH' "$1" "$2"; }
# Clear screen
clear_screen() { printf '\033[2J\033[H'; }
# Hide cursor
hide_cursor() { printf '\033[?25l'; }
# Show cursor
show_cursor() { printf '\033[?25h'; }
# Clear to end of line
clear_eol() { printf '\033[K'; }

# Track if static elements have been drawn
TUI_INITIALIZED=0

# Draw a progress bar
# Args: width percent [color]
draw_progress_bar() {
  local width=$1
  local percent=$2
  local color="${3:-$GREEN}"

  local filled=$((width * percent / 100))
  local empty=$((width - filled))

  printf "${color}"
  printf '█%.0s' $(seq 1 $filled 2>/dev/null) || true
  printf "${GRAY}"
  printf '░%.0s' $(seq 1 $empty 2>/dev/null) || true
  printf "${NC}"
}

# Draw a box
# Args: row col width height title
draw_box() {
  local row=$1 col=$2 width=$3 height=$4 title="$5"

  cursor_to $row $col
  printf "┌─${CYAN}${BOLD} %s ${NC}" "$title"
  local title_len=$((${#title} + 3))
  local remaining=$((width - title_len - 2))
  printf '─%.0s' $(seq 1 $remaining)
  printf "┐"

  for ((i=1; i<height-1; i++)); do
    cursor_to $((row + i)) $col
    printf "│"
    cursor_to $((row + i)) $((col + width - 1))
    printf "│"
  done

  cursor_to $((row + height - 1)) $col
  printf "└"
  printf '─%.0s' $(seq 1 $((width - 2)))
  printf "┘"
}

# Draw static elements (boxes, labels) - only once
draw_static_ui() {
  local term_width term_height
  term_width=$(tput cols 2>/dev/null || echo 120)
  term_height=$(tput lines 2>/dev/null || echo 40)

  clear_screen

  # Header
  cursor_to 1 1
  printf "${BG_DARK}${WHITE}${BOLD}"
  printf "  %-$((term_width-2))s" "muxm-pipeline"
  printf "${NC}"

  # System stats labels (row 2)
  cursor_to 2 1
  printf "${BG_GRAY}  CPU:              RAM:                           "
  if command -v nvidia-smi &>/dev/null; then
    printf "GPU:                         "
  fi
  printf "${NC}"
  clear_eol

  # Progress label (row 4)
  cursor_to 4 1
  printf "  ${BOLD}Progress:${NC} "

  # Worker grid boxes (taller to fit wrapped filenames)
  local box_width=38
  local box_height=8
  local cols=2
  local start_row=6

  (( term_width >= 120 )) && cols=3
  (( term_width >= 160 )) && cols=4

  for ((w=1; w<=MAX_WORKERS; w++)); do
    local row=$(( start_row + ((w-1) / cols) * (box_height + 1) ))
    local col=$(( 2 + ((w-1) % cols) * (box_width + 2) ))
    draw_box $row $col $box_width $box_height "Worker $w"
  done

  # Recent label
  local recent_row=$((start_row + ((MAX_WORKERS + cols - 1) / cols) * (box_height + 1) + 1))
  cursor_to $recent_row 1
  printf "${BOLD}Recent:${NC} "

  # Footer
  cursor_to $((recent_row + 2)) 1
  printf "${DIM}Press Ctrl+C to abort${NC}"
}

# Draw dynamic elements (progress bars, values) - every refresh
draw_dynamic_ui() {
  local term_width
  term_width=$(tput cols 2>/dev/null || echo 120)

  # Get system stats
  local cpu_pct ram_pct ram_used ram_total gpu_info
  cpu_pct=$(get_cpu_usage)
  read -r ram_pct ram_used ram_total <<< "$(get_ram_usage)"
  gpu_info=$(get_gpu_usage)

  # Get progress stats
  local completed failed skipped elapsed eta speed
  completed=$(cat "$STATUS_DIR/completed" 2>/dev/null || echo 0)
  failed=$(cat "$STATUS_DIR/failed" 2>/dev/null || echo 0)
  skipped=$(cat "$STATUS_DIR/skipped" 2>/dev/null || echo 0)
  local now=$(date +%s)
  elapsed=$((now - START_TIME))

  local processed=$((completed + failed + skipped))
  local remaining=$((TOTAL_FILES - processed))

  if (( processed > 0 && elapsed > 0 )); then
    local rate_per_sec=$(echo "scale=4; $processed / $elapsed" | bc 2>/dev/null || echo 0)
    if [[ "$rate_per_sec" != "0" && "$rate_per_sec" != "" ]]; then
      local eta_secs=$(echo "scale=0; $remaining / $rate_per_sec" | bc 2>/dev/null || echo 0)
      eta=$(format_duration $eta_secs)
      speed=$(echo "scale=1; $processed * 60 / $elapsed" | bc 2>/dev/null || echo "0")
    else
      eta="--:--:--"
      speed="0"
    fi
  else
    eta="--:--:--"
    speed="0"
  fi

  local progress_pct=0
  (( TOTAL_FILES > 0 )) && progress_pct=$((processed * 100 / TOTAL_FILES))

  # Update system stats (row 2) - just the values
  cursor_to 2 8
  draw_progress_bar 10 $cpu_pct $CYAN
  printf " %3d%%" "$cpu_pct"

  cursor_to 2 28
  draw_progress_bar 10 $ram_pct $MAGENTA
  printf " %3d%% (%2dG/%2dG)" "$ram_pct" "$ram_used" "$ram_total"

  if [[ "$gpu_info" != "N/A" ]]; then
    local gpu_pct gpu_mem_used gpu_mem_total
    IFS=',' read -r gpu_pct gpu_mem_used gpu_mem_total <<< "$gpu_info"
    cursor_to 2 56
    draw_progress_bar 10 ${gpu_pct:-0} $YELLOW
    printf " %3d%% (%5sM/%5sM)" "${gpu_pct:-0}" "${gpu_mem_used:-0}" "${gpu_mem_total:-0}"
  fi

  # Update progress bar (row 4)
  cursor_to 4 13
  draw_progress_bar 40 $progress_pct $GREEN
  printf " %4d/%-4d (%3d%%)  " "$processed" "$TOTAL_FILES" "$progress_pct"
  printf "${DIM}Elapsed: $(format_duration $elapsed)  ETA: $eta  Speed: ${speed}/min${NC}"
  clear_eol

  # Worker grid content
  local box_width=38
  local box_height=8
  local cols=2
  local start_row=6

  (( term_width >= 120 )) && cols=3
  (( term_width >= 160 )) && cols=4

  for ((w=1; w<=MAX_WORKERS; w++)); do
    local row=$(( start_row + ((w-1) / cols) * (box_height + 1) ))
    local col=$(( 2 + ((w-1) % cols) * (box_width + 2) ))

    # Read worker status
    local state="IDLE" filename="" step="" progress=0
    if [[ -f "$STATUS_DIR/workers/$w" ]]; then
      source "$STATUS_DIR/workers/$w" 2>/dev/null || true
    fi

    # State indicator
    cursor_to $((row + 1)) $((col + 2))
    case "$state" in
      IDLE)     printf "${GRAY}○ IDLE     ${NC}" ;;
      COPYING)  printf "${YELLOW}● COPYING  ${NC}" ;;
      ENCODING) printf "${GREEN}● ENCODING ${NC}" ;;
      MUXING)   printf "${CYAN}● MUXING   ${NC}" ;;
      MOVING)   printf "${BLUE}● MOVING   ${NC}" ;;
      VERIFY)   printf "${MAGENTA}● VERIFYING${NC}" ;;
      *)        printf "${WHITE}● %-9s${NC}" "$state" ;;
    esac

    # Filename - wrapped across 3 lines
    local max_len=$((box_width - 4))
    if [[ -n "$filename" ]]; then
      local len=${#filename}
      # Line 1
      cursor_to $((row + 2)) $((col + 2))
      printf "${WHITE}%-${max_len}s${NC}" "${filename:0:$max_len}"
      # Line 2 (if needed)
      cursor_to $((row + 3)) $((col + 2))
      if (( len > max_len )); then
        printf "${WHITE}%-${max_len}s${NC}" "${filename:$max_len:$max_len}"
      else
        printf "%-${max_len}s" ""
      fi
      # Line 3 (if needed)
      cursor_to $((row + 4)) $((col + 2))
      if (( len > max_len * 2 )); then
        printf "${WHITE}%-${max_len}s${NC}" "${filename:$((max_len*2)):$max_len}"
      else
        printf "%-${max_len}s" ""
      fi
    else
      cursor_to $((row + 2)) $((col + 2))
      printf "${DIM}%-${max_len}s${NC}" "Waiting for work..."
      cursor_to $((row + 3)) $((col + 2))
      printf "%-${max_len}s" ""
      cursor_to $((row + 4)) $((col + 2))
      printf "%-${max_len}s" ""
    fi

    # Step - fixed width field
    cursor_to $((row + 5)) $((col + 2))
    printf "${DIM}%-${max_len}s${NC}" "${step:0:$max_len}"

    # Progress bar
    cursor_to $((row + 6)) $((col + 2))
    if [[ "$state" != "IDLE" ]]; then
      draw_progress_bar 20 $progress $GREEN
      printf " %3d%%" "$progress"
    else
      printf "%-25s" ""  # Clear the progress bar area
    fi
  done

  # Recent completions
  local recent_row=$((start_row + ((MAX_WORKERS + cols - 1) / cols) * (box_height + 1) + 1))
  cursor_to $recent_row 10

  if [[ -f "$STATUS_DIR/recent/log" ]]; then
    local count=0
    while IFS=: read -r status fname ts; do
      (( count++ > 5 )) && break
      case "$status" in
        success) printf "${GREEN}✓${NC} " ;;
        skipped) printf "${YELLOW}○${NC} " ;;
        *)       printf "${RED}✗${NC} " ;;
      esac
      local short="${fname##*/}"
      (( ${#short} > 18 )) && short="${short:0:15}..."
      printf "%-18s " "$short"
    done < <(tac "$STATUS_DIR/recent/log" 2>/dev/null)
  fi
  clear_eol
}

# Draw the main TUI (calls static once, then dynamic)
draw_monitor_ui() {
  if (( TUI_INITIALIZED == 0 )); then
    draw_static_ui
    TUI_INITIALIZED=1
  fi
  draw_dynamic_ui
}

# Monitor loop - runs in background
run_monitor_loop() {
  hide_cursor
  trap 'show_cursor; clear_screen' EXIT

  while true; do
    draw_monitor_ui
    sleep 1
  done
}

# ---------- Usage ----------
print_usage() {
  cat <<EOF
muxm-pipeline - High-performance batch processor with local caching

Copies files from NFS to local NVMe cache, processes them, then moves
back to NFS. Prefetches next files while processing for maximum throughput.

Usage: muxm-pipeline [OPTIONS] INPUT_DIR [OUTPUT_DIR]

Arguments:
  INPUT_DIR             Source directory (typically NFS mount)
  OUTPUT_DIR            Destination directory (default: INPUT_DIR, replaces originals)

Cache Options:
  -c, --cache-dir DIR   Cache directory (default: $CACHE_DIR)
  --cache-max-gb N      Max cache usage in GB (default: $CACHE_MAX_GB)
  --prefetch N          Files to prefetch ahead (default: $PREFETCH_COUNT)

Processing Options:
  -w, --workers N       Parallel muxm workers (default: $MAX_WORKERS)
  -r, --recursive       Process subdirectories (default: on)
  -R, --no-recursive    Only process INPUT_DIR
  -e, --extensions LIST Comma-separated extensions (default: mkv,mp4,...)

Output Options:
  --delete-original     Delete source after successful conversion
  --no-delete-original  Keep source files (default, safe)

Filebot Renaming (optional):
  --filebot             Enable filebot for proper media naming
  --filebot-db DB       Database: TheMovieDB, TheMovieDB::TV, TheTVDB, etc.
  --filebot-format FMT  Custom format string (overrides default)
  --filebot-action ACT  move, copy, hardlink, symlink (default: move)
  --filebot-lang LANG   Metadata language (default: en)

Other:
  --dry-run             Show what would be processed
  --no-monitor          Disable TUI monitor (use simple log output)
  -v, --verbose         Verbose output
  -h, --help            Show this help

Examples:
  # Process movies, keep originals
  muxm-pipeline /srv/plex-storage/Movies

  # Process and replace originals (CAREFUL!)
  muxm-pipeline --delete-original /srv/plex-storage/Movies

  # Process TV shows with more workers
  muxm-pipeline -w 8 /srv/plex-storage/TV

  # Custom cache location
  muxm-pipeline -c /mnt/nvme/cache /srv/plex-storage/Movies

  # Use filebot for TV show naming (requires filebot installed)
  muxm-pipeline --filebot --filebot-db TheMovieDB::TV /srv/plex-storage/TV

  # Use filebot for movies
  muxm-pipeline --filebot --filebot-db TheMovieDB /srv/plex-storage/Movies

Cache Strategy:
  - Files copied to local NVMe before processing
  - Next $PREFETCH_COUNT files prefetched while current batch processes
  - Output written locally, then moved to destination
  - Cache cleaned after each file completes
EOF
}

# ---------- Parse Arguments ----------
INPUT_DIR=""
OUTPUT_DIR=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    -c|--cache-dir)     CACHE_DIR="${2:-}"; shift 2 ;;
    --cache-max-gb)     CACHE_MAX_GB="${2:-}"; shift 2 ;;
    --prefetch)         PREFETCH_COUNT="${2:-}"; shift 2 ;;
    -w|--workers)       MAX_WORKERS="${2:-}"; shift 2 ;;
    -r|--recursive)     RECURSIVE=1; shift ;;
    -R|--no-recursive)  RECURSIVE=0; shift ;;
    -e|--extensions)    FILE_EXTENSIONS="${2:-}"; shift 2 ;;
    --delete-original)  DELETE_ORIGINAL=1; shift ;;
    --no-delete-original) DELETE_ORIGINAL=0; shift ;;
    --verify)           VERIFY_OUTPUT=1; shift ;;
    --no-verify)        VERIFY_OUTPUT=0; shift ;;
    --filebot)          USE_FILEBOT=1; shift ;;
    --filebot-db)       FILEBOT_DB="${2:-}"; shift 2 ;;
    --filebot-format)   FILEBOT_FORMAT="${2:-}"; shift 2 ;;
    --filebot-action)   FILEBOT_ACTION="${2:-}"; shift 2 ;;
    --filebot-lang)     FILEBOT_LANG="${2:-}"; shift 2 ;;
    --dry-run)          DRY_RUN=1; shift ;;
    --no-monitor)       MONITOR_UI=0; shift ;;
    -v|--verbose)       VERBOSE=1; shift ;;
    -h|--help)          print_usage; exit 0 ;;
    -*)                 die "Unknown option: $1" ;;
    *)
      if [[ -z "$INPUT_DIR" ]]; then
        INPUT_DIR="$1"
      elif [[ -z "$OUTPUT_DIR" ]]; then
        OUTPUT_DIR="$1"
      else
        die "Unexpected argument: $1"
      fi
      shift
      ;;
  esac
done

# Validate
[[ -z "$INPUT_DIR" ]] && { print_usage; die "INPUT_DIR is required"; }
[[ ! -d "$INPUT_DIR" ]] && die "INPUT_DIR does not exist: $INPUT_DIR"

# Convert to absolute paths to avoid issues with filenames containing special chars
INPUT_DIR="$(cd "$INPUT_DIR" && pwd)"
[[ -z "$OUTPUT_DIR" ]] && OUTPUT_DIR="$INPUT_DIR"
[[ -d "$OUTPUT_DIR" ]] && OUTPUT_DIR="$(cd "$OUTPUT_DIR" && pwd)"

# Update cache paths
CACHE_INPUT="$CACHE_DIR/input"
CACHE_OUTPUT="$CACHE_DIR/output"
CACHE_TEMP="$CACHE_DIR/temp"

# ---------- Find muxm ----------
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MUXM_BIN="$SCRIPT_DIR/muxm"
[[ ! -x "$MUXM_BIN" ]] && MUXM_BIN="$(command -v muxm 2>/dev/null || true)"
[[ ! -x "$MUXM_BIN" ]] && die "Cannot find muxm script"

# ---------- Find filebot (optional) ----------
find_filebot() {
  # Check common locations
  local candidates=(
    "$(command -v filebot 2>/dev/null || true)"
    "/usr/bin/filebot"
    "/usr/local/bin/filebot"
    "/opt/filebot/filebot"
    "$HOME/.local/share/filebot/filebot"
    "$HOME/bin/filebot"
  )

  for fb in "${candidates[@]}"; do
    if [[ -n "$fb" && -x "$fb" ]]; then
      echo "$fb"
      return 0
    fi
  done
  return 1
}

# Auto-detect filebot if enabled
if (( USE_FILEBOT )); then
  FILEBOT_BIN=$(find_filebot || true)
  if [[ -z "$FILEBOT_BIN" ]]; then
    warn "Filebot not found. Disabling filebot renaming."
    warn "Install filebot: https://www.filebot.net/download.html"
    USE_FILEBOT=0
  else
    note "Filebot found: $FILEBOT_BIN"
  fi
fi

# ---------- Filebot Renaming ----------
# Rename a file using filebot
# Args: input_file output_dir
# Returns: 0 on success, 1 on failure
# On success, echoes the new filename to stdout
filebot_rename() {
  local input_file="$1"
  local output_dir="$2"
  local log_file="${3:-/dev/null}"

  if [[ -z "$FILEBOT_BIN" || ! -x "$FILEBOT_BIN" ]]; then
    # Filebot not available, just return the input filename
    echo "$input_file"
    return 0
  fi

  # Build filebot command
  local fb_cmd=("$FILEBOT_BIN" -rename "$input_file")
  fb_cmd+=(--db "$FILEBOT_DB")
  fb_cmd+=(--action "$FILEBOT_ACTION")
  fb_cmd+=(--conflict "$FILEBOT_CONFLICT")
  fb_cmd+=(--lang "$FILEBOT_LANG")
  fb_cmd+=(--output "$output_dir")

  # Add format if specified
  if [[ -n "$FILEBOT_FORMAT" ]]; then
    fb_cmd+=(--format "$FILEBOT_FORMAT")
  fi

  # Add non-strict matching for better results
  fb_cmd+=(--non-strict)

  echo "Running: ${fb_cmd[*]}" >> "$log_file"

  # Run filebot and capture output
  local fb_output
  if fb_output=$("${fb_cmd[@]}" 2>> "$log_file"); then
    # Parse output to find the new filename
    # Filebot outputs lines like: [MOVE] from [/path/to/old] to [/path/to/new]
    local new_file
    new_file=$(echo "$fb_output" | grep -oP '(?<=to \[)[^\]]+' | tail -1)
    if [[ -n "$new_file" && -f "$new_file" ]]; then
      echo "$new_file"
      return 0
    else
      # Fallback: check if file still exists at original location
      if [[ -f "$input_file" ]]; then
        warn "Filebot ran but file not renamed. Using original." >> "$log_file"
        echo "$input_file"
        return 0
      fi
    fi
  fi

  # Failed - return original file if it still exists
  if [[ -f "$input_file" ]]; then
    echo "$input_file"
    return 0
  fi

  return 1
}

# Get default filebot format based on content type
get_default_filebot_format() {
  local db="$1"
  case "$db" in
    *TV*|*tvdb*|*thetvdb*)
      # TV show format: Show Name/Season XX/Show Name - S01E02 - Episode Title.ext
      echo '{plex.tail}'
      ;;
    *movie*|*Movie*)
      # Movie format: Movie Name (Year)/Movie Name (Year).ext
      echo '{plex.tail}'
      ;;
    *)
      # Default to Plex naming
      echo '{plex.tail}'
      ;;
  esac
}

# ---------- Cache Management ----------
get_cache_usage_gb() {
  du -s "$CACHE_DIR" 2>/dev/null | awk '{print int($1/1024/1024)}'
}

wait_for_cache_space() {
  local needed_gb="$1"
  local max_wait=300  # 5 minutes max
  local waited=0

  while true; do
    local used_gb=$(get_cache_usage_gb)
    local available_gb=$((CACHE_MAX_GB - used_gb))

    if (( available_gb >= needed_gb )); then
      return 0
    fi

    if (( waited >= max_wait )); then
      warn "Timeout waiting for cache space (need ${needed_gb}GB, have ${available_gb}GB)"
      return 1
    fi

    debug "Waiting for cache space: need ${needed_gb}GB, available ${available_gb}GB"
    sleep 5
    ((waited += 5))
  done
}

cleanup_cache_file() {
  local src_basename="$1"
  local dst_name="$2"
  local dst_no_ext="${dst_name%.mp4}"
  rm -f "$CACHE_INPUT/$src_basename" \
        "$CACHE_OUTPUT/$dst_name" \
        "$CACHE_OUTPUT/${dst_no_ext}.srt" 2>/dev/null || true
}

# ---------- Pre-Processing Check ----------
# Check if file is already in desired format (skip processing if so)
# Returns 0 if file should be SKIPPED, 1 if it needs processing
is_already_processed() {
  local file="$1"
  local basename="${file##*/}"
  local ext="${basename##*.}"
  ext="${ext,,}"  # lowercase

  # Must be MP4 container
  [[ "$ext" != "mp4" && "$ext" != "m4v" ]] && return 1

  # Get stream info with ffprobe
  local probe_output
  probe_output=$(ffprobe -v quiet -print_format json -show_streams "$file" 2>/dev/null) || return 1

  # Check video codec - must be H.264 or HEVC
  local video_codec
  video_codec=$(echo "$probe_output" | grep -o '"codec_name": *"[^"]*"' | head -1 | cut -d'"' -f4)
  case "$video_codec" in
    h264|hevc) ;;  # OK
    *) return 1 ;; # Needs transcoding
  esac

  # Get audio streams info
  local audio_streams
  audio_streams=$(echo "$probe_output" | python3 -c "
import sys, json
data = json.load(sys.stdin)
audio = [s for s in data.get('streams', []) if s.get('codec_type') == 'audio']
for i, a in enumerate(audio):
    codec = a.get('codec_name', '')
    channels = a.get('channels', 0)
    print(f'{i}:{codec}:{channels}')
" 2>/dev/null) || return 1

  # Parse audio streams
  local has_aac_surround=0
  local has_aac_stereo=0
  local primary_channels=0

  while IFS=: read -r idx codec channels; do
    [[ -z "$codec" ]] && continue
    if [[ "$codec" == "aac" ]]; then
      if (( channels >= 6 )); then
        has_aac_surround=1
        (( idx == 0 )) && primary_channels=$channels
      elif (( channels == 2 )); then
        has_aac_stereo=1
        (( idx == 0 )) && primary_channels=$channels
      fi
    fi
  done <<< "$audio_streams"

  # Decision logic:
  # - If primary is surround AAC and we have stereo fallback: SKIP
  # - If primary is stereo AAC (source was stereo): SKIP
  # - Otherwise: needs processing
  if (( has_aac_surround && has_aac_stereo )); then
    # Has surround + stereo fallback - already processed
    return 0
  elif (( primary_channels == 2 && has_aac_stereo )); then
    # Primary is stereo AAC - already processed (source was stereo)
    return 0
  fi

  # Needs processing
  return 1
}

# ---------- File Discovery ----------
build_file_list() {
  local -a find_args=("$INPUT_DIR")
  (( RECURSIVE == 0 )) && find_args+=(-maxdepth 1)
  find_args+=(-type f \()

  local first=1
  IFS=',' read -ra exts <<< "$FILE_EXTENSIONS"
  for ext in "${exts[@]}"; do
    ext="$(echo "$ext" | tr -d '[:space:]')"
    (( first )) && first=0 || find_args+=(-o)
    find_args+=(-iname "*.$ext")
  done
  find_args+=(\))

  # Use find directly (no eval) with proper quoting
  find "${find_args[@]}" 2>/dev/null | sort
}

# ---------- Format-Aware Renaming ----------
# Keeps original filename structure but updates codec tags to reflect actual output.
# Example: Tick.Tick.Boom.2021.iTA-ENG.Bluray.1080p.x264-CYBER.mkv
#       -> Tick.Tick.Boom.2021.iTA-ENG.Bluray.1080p.x264.AAC.5.1-CYBER.mp4

# Get actual output format info by probing the source file
get_output_format_info() {
  local file="$1"
  local vcodec achannels

  # Video codec from source (determines passthrough vs transcode)
  vcodec=$(ffprobe -v quiet -select_streams v:0 -show_entries stream=codec_name \
           -of default=nk=1:nw=1 "$file" 2>/dev/null | head -1 | tr '[:upper:]' '[:lower:]')

  # Determine output video codec tag
  case "$vcodec" in
    h264|avc|avc1)  OUT_VCODEC_TAG="x264" ;;
    hevc|h265)      OUT_VCODEC_TAG="x265" ;;
    *)              OUT_VCODEC_TAG="x265" ;;  # Non-passthrough codecs get transcoded to H.265
  esac

  # Audio channels from source (output will be AAC with same channel count, capped at 8)
  achannels=$(ffprobe -v quiet -select_streams a:0 -show_entries stream=channels \
              -of default=nk=1:nw=1 "$file" 2>/dev/null | head -1)
  [[ -z "$achannels" ]] && achannels=2

  # Determine audio format tag
  case "$achannels" in
    8)       OUT_ACODEC_TAG="AAC.7.1" ;;
    6)       OUT_ACODEC_TAG="AAC.5.1" ;;
    2|1)     OUT_ACODEC_TAG="AAC" ;;
    *)       OUT_ACODEC_TAG="AAC.5.1" ;;  # Default to 5.1 for other multichannel
  esac
}

# Extract release group from filename (text after last hyphen before extension)
extract_release_group() {
  local name="$1"
  # Match -GROUP at end, where GROUP is alphanumeric (possibly with underscores)
  if [[ "$name" =~ -([A-Za-z0-9_]+)$ ]]; then
    echo "${BASH_REMATCH[1]}"
  else
    echo ""
  fi
}

# Remove release group suffix from name
strip_release_group() {
  local name="$1"
  local group="$2"
  if [[ -n "$group" ]]; then
    echo "${name%-$group}"
  else
    echo "$name"
  fi
}

# Remove existing audio codec tags from filename
strip_audio_codec_tags() {
  local name="$1"
  # Remove common audio codec patterns (case insensitive)
  # Patterns: DTS-HD.MA, DTS-HD, DTS, TrueHD, Atmos, DD5.1, DD+, EAC3, AC3, AAC, FLAC, etc.
  name=$(echo "$name" | sed -E 's/[._-]?(DTS-HD\.?MA|DTS-HD|DTS|TrueHD|Atmos|DD\+?5\.1|DD\+|EAC3|E-AC-3|AC3|AAC\.?[0-9.]*|FLAC|LPCM|PCM)([._-]|$)/\2/gi')
  # Clean up any double dots/dashes left behind
  name=$(echo "$name" | sed -E 's/[._-]{2,}/./g' | sed -E 's/[._-]$//')
  echo "$name"
}

# Remove existing video codec tags from filename (only if we need to change them)
strip_video_codec_tags() {
  local name="$1"
  # Remove common video codec patterns
  name=$(echo "$name" | sed -E 's/[._-]?(x264|x265|h\.?264|h\.?265|HEVC|AVC|XviD|DivX|VP9|AV1)([._-]|$)/\2/gi')
  # Clean up any double dots/dashes left behind
  name=$(echo "$name" | sed -E 's/[._-]{2,}/./g' | sed -E 's/[._-]$//')
  echo "$name"
}

# Check if filename already has a video codec tag
has_video_codec_tag() {
  local name="$1"
  [[ "$name" =~ [._-](x264|x265|h\.?264|h\.?265|HEVC|AVC|XviD|DivX|VP9|AV1)[._-]? ]]
}

generate_output_name() {
  local src_path="$1"
  local basename="${src_path##*/}"
  local name_no_ext="${basename%.*}"

  # Get output format info
  get_output_format_info "$src_path"

  # Extract and temporarily remove release group
  local release_group
  release_group=$(extract_release_group "$name_no_ext")
  local name_work
  name_work=$(strip_release_group "$name_no_ext" "$release_group")

  # Strip existing audio codec tags
  name_work=$(strip_audio_codec_tags "$name_work")

  # Check source video codec to see if we need to update video tag
  local src_vcodec
  src_vcodec=$(ffprobe -v quiet -select_streams v:0 -show_entries stream=codec_name \
               -of default=nk=1:nw=1 "$src_path" 2>/dev/null | head -1 | tr '[:upper:]' '[:lower:]')

  # Determine if video codec tag needs updating
  local needs_video_update=0
  case "$src_vcodec" in
    h264|avc|avc1|hevc|h265)
      # Passthrough - keep existing tag if present, or don't add
      needs_video_update=0
      ;;
    *)
      # Transcoding to H.265 - need to update/add video tag
      needs_video_update=1
      ;;
  esac

  # If transcoding, strip old video tag and add new one
  if (( needs_video_update )); then
    name_work=$(strip_video_codec_tags "$name_work")
    name_work="${name_work}.${OUT_VCODEC_TAG}"
  fi

  # Add audio codec tag
  name_work="${name_work}.${OUT_ACODEC_TAG}"

  # Re-add release group if present
  if [[ -n "$release_group" ]]; then
    name_work="${name_work}-${release_group}"
  fi

  # Clean up any formatting issues
  name_work=$(echo "$name_work" | sed -E 's/[._-]{2,}/./g')

  echo "${name_work}.mp4"
}

# ---------- Single File Processing ----------
process_single_file() {
  local src_nfs="$1"
  local dst_nfs_dir="$2"
  local log_file="$3"
  local worker_id="${4:-0}"

  local basename="${src_nfs##*/}"
  local rel_path="${src_nfs#$INPUT_DIR/}"
  local rel_dir="$(dirname "$rel_path")"
  [[ "$rel_dir" == "." ]] && rel_dir=""

  local src_cached="$CACHE_INPUT/$basename"
  local dst_name=$(generate_output_name "$src_nfs")
  local dst_cached="$CACHE_OUTPUT/$dst_name"
  local dst_final="$dst_nfs_dir${rel_dir:+/$rel_dir}/$dst_name"

  # Get file size for cache management
  local file_size_gb
  file_size_gb=$(du -s "$src_nfs" 2>/dev/null | awk '{print int($1/1024/1024 + 1)}')

  # Capture original file's permissions and ownership for later
  local orig_perms orig_owner orig_group
  orig_perms=$(stat -c '%a' "$src_nfs" 2>/dev/null) || orig_perms=""
  orig_owner=$(stat -c '%u' "$src_nfs" 2>/dev/null) || orig_owner=""
  orig_group=$(stat -c '%g' "$src_nfs" 2>/dev/null) || orig_group=""

  echo "=== Processing: $rel_path ===" >> "$log_file"
  echo "Source: $src_nfs" >> "$log_file"
  echo "Size: ${file_size_gb}GB" >> "$log_file"
  echo "Original perms: $orig_perms, owner: $orig_owner:$orig_group" >> "$log_file"

  # Pre-check: Is file already in desired format? (check on NFS, no copy needed)
  update_worker_status "$worker_id" "VERIFY" "$basename" "Checking format..." 0
  echo "Checking if already processed..." >> "$log_file"
  if is_already_processed "$src_nfs"; then
    echo "SKIPPED: File already has AAC audio with stereo fallback" >> "$log_file"
    update_worker_status "$worker_id" "IDLE" "" "" 0
    return 2  # Special return code for "skipped"
  fi
  echo "File needs processing" >> "$log_file"

  # Wait for cache space (need space for input + output, estimate 1.2x for output)
  local needed_space=$((file_size_gb * 3))
  if ! wait_for_cache_space "$needed_space"; then
    echo "FAIL: Insufficient cache space" >> "$log_file"
    return 1
  fi

  # Copy to cache
  update_worker_status "$worker_id" "COPYING" "$basename" "Copying to cache..." 5
  echo "Copying to cache..." >> "$log_file"
  if ! cp "$src_nfs" "$src_cached" 2>> "$log_file"; then
    echo "FAIL: Copy to cache failed" >> "$log_file"
    cleanup_cache_file "$basename" "$dst_name"
    return 1
  fi
  update_worker_status "$worker_id" "COPYING" "$basename" "Copied to cache" 10

  # Process
  update_worker_status "$worker_id" "ENCODING" "$basename" "Processing with muxm..." 15
  echo "Processing with muxm..." >> "$log_file"
  export TMPDIR="$CACHE_TEMP"
  if ! "$MUXM_BIN" "$src_cached" "$dst_cached" >> "$log_file" 2>&1; then
    echo "FAIL: muxm processing failed" >> "$log_file"
    cleanup_cache_file "$basename" "$dst_name"
    return 1
  fi
  update_worker_status "$worker_id" "ENCODING" "$basename" "Encoding complete" 70

  # Verify output
  if (( VERIFY_OUTPUT )); then
    update_worker_status "$worker_id" "VERIFY" "$basename" "Verifying output..." 75
    echo "Verifying output..." >> "$log_file"
    if ! ffprobe -v error "$dst_cached" >> "$log_file" 2>&1; then
      echo "FAIL: Output verification failed" >> "$log_file"
      cleanup_cache_file "$basename" "$dst_name"
      return 1
    fi
    update_worker_status "$worker_id" "VERIFY" "$basename" "Verification passed" 85
  fi

  # Move to destination
  update_worker_status "$worker_id" "MOVING" "$basename" "Moving to NFS..." 90
  echo "Moving to destination: $dst_final" >> "$log_file"
  mkdir -p "$(dirname "$dst_final")"
  if ! mv "$dst_cached" "$dst_final" 2>> "$log_file"; then
    echo "FAIL: Move to destination failed" >> "$log_file"
    cleanup_cache_file "$basename" "$dst_name"
    return 1
  fi

  # Also move SRT sidecar if it exists
  local srt_cached="${dst_cached%.mp4}.srt"
  local srt_final="${dst_final%.mp4}.srt"
  if [[ -f "$srt_cached" ]]; then
    echo "Moving SRT sidecar: $srt_final" >> "$log_file"
    mv "$srt_cached" "$srt_final" 2>> "$log_file" || warn "Could not move SRT sidecar"
  fi

  # Apply original file's permissions and ownership to output files
  echo "Applying original permissions/ownership..." >> "$log_file"
  if [[ -n "$orig_perms" ]]; then
    chmod "$orig_perms" "$dst_final" 2>> "$log_file" || warn "Could not set permissions on $dst_final"
    [[ -f "$srt_final" ]] && chmod "$orig_perms" "$srt_final" 2>> "$log_file" || true
  fi
  if [[ -n "$orig_owner" && -n "$orig_group" ]]; then
    chown "${orig_owner}:${orig_group}" "$dst_final" 2>> "$log_file" || warn "Could not set ownership on $dst_final"
    [[ -f "$srt_final" ]] && chown "${orig_owner}:${orig_group}" "$srt_final" 2>> "$log_file" || true
  fi

  # Filebot renaming (optional)
  local final_path="$dst_final"
  if (( USE_FILEBOT )); then
    echo "Running filebot for proper naming..." >> "$log_file"
    local fb_result
    if fb_result=$(filebot_rename "$dst_final" "$dst_nfs_dir" "$log_file"); then
      if [[ -n "$fb_result" && -f "$fb_result" ]]; then
        final_path="$fb_result"
        echo "Filebot renamed to: $final_path" >> "$log_file"
      else
        echo "Filebot: kept original name" >> "$log_file"
      fi
    else
      echo "Filebot rename failed, keeping original name" >> "$log_file"
    fi
  fi

  # Delete original if requested
  if (( DELETE_ORIGINAL )); then
    echo "Deleting original: $src_nfs" >> "$log_file"
    rm -f "$src_nfs" 2>> "$log_file" || warn "Could not delete original: $src_nfs"
  fi

  # Cleanup cache
  cleanup_cache_file "$basename" "$dst_name"

  update_worker_status "$worker_id" "IDLE" "" "" 100
  echo "SUCCESS: ${final_path##*/}" >> "$log_file"
  return 0
}

# ---------- Main ----------
say "=== muxm-pipeline ==="
say "Input:       $INPUT_DIR"
say "Output:      $OUTPUT_DIR"
say "Cache:       $CACHE_DIR"
say "Max Cache:   ${CACHE_MAX_GB}GB"
say "Workers:     $MAX_WORKERS"
say "Prefetch:    $PREFETCH_COUNT"
say "Delete Orig: $(( DELETE_ORIGINAL )) ($(( DELETE_ORIGINAL )) && echo 'ENABLED!' || echo 'disabled')"
if (( USE_FILEBOT )); then
  say "Filebot:     ENABLED (db=$FILEBOT_DB)"
else
  say "Filebot:     disabled"
fi
echo ""

# Safety warning
if (( DELETE_ORIGINAL )); then
  warn "========================================"
  warn "  DELETE_ORIGINAL is ENABLED!"
  warn "  Source files will be DELETED after"
  warn "  successful conversion."
  warn "========================================"
  echo ""
  read -p "Continue? [y/N] " -n 1 -r
  echo
  [[ ! $REPLY =~ ^[Yy]$ ]] && exit 1
fi

# Create cache directories
mkdir -p "$CACHE_INPUT" "$CACHE_OUTPUT" "$CACHE_TEMP"

# Create log directory
LOG_DIR="$CACHE_DIR/logs"
mkdir -p "$LOG_DIR"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
MAIN_LOG="$LOG_DIR/pipeline-$TIMESTAMP.log"
FAILED_LOG="$LOG_DIR/failed-$TIMESTAMP.txt"
SUCCESS_LOG="$LOG_DIR/success-$TIMESTAMP.txt"

# Get file list
say "Scanning for files..."
FILE_LIST=$(build_file_list)
TOTAL_FILES=$(echo "$FILE_LIST" | grep -c . || echo 0)
say "Found $TOTAL_FILES files"
echo ""

if (( TOTAL_FILES == 0 )); then
  note "No files to process."
  exit 0
fi

if (( DRY_RUN )); then
  say "DRY-RUN: Files that would be processed:"
  echo "$FILE_LIST" | while read -r f; do
    [[ -n "$f" ]] && echo "  $f -> $(generate_output_name "$f")"
  done
  exit 0
fi

# Initialize status tracking
init_status_dir

# Process files with parallel workers
PROCESSED=0
SUCCEEDED=0
FAILED=0

# Temp files for tracking results across subshells
RESULT_DIR=$(mktemp -d)
trap 'cleanup_status_dir; rm -rf "$RESULT_DIR"; (( MONITOR_UI )) && show_cursor' EXIT

# Start monitor UI if enabled
MONITOR_PID=""
if (( MONITOR_UI )); then
  run_monitor_loop &
  MONITOR_PID=$!
fi

# Worker function - runs in background
process_worker() {
  local src_file="$1"
  local worker_id="$2"
  local result_file="$RESULT_DIR/result_$worker_id"

  local rel_path="${src_file#$INPUT_DIR/}"
  local basename="${src_file##*/}"
  local log_file="$LOG_DIR/$(echo "$rel_path" | tr '/' '_' | tr ' ' '_').log"

  (( MONITOR_UI )) || say "[Worker $worker_id] Processing: $rel_path"
  update_worker_status "$worker_id" "VERIFY" "$basename" "Checking..." 0

  process_single_file "$src_file" "$OUTPUT_DIR" "$log_file" "$worker_id"
  local ret=$?

  case $ret in
    0)  # Success
      echo "SUCCESS:$src_file" > "$result_file"
      increment_completed
      add_recent "success" "$basename"
      clear_worker_status "$worker_id"
      (( MONITOR_UI )) || note "[Worker $worker_id] SUCCESS: ${rel_path##*/}"
      ;;
    2)  # Skipped (already processed)
      echo "SKIPPED:$src_file" > "$result_file"
      increment_skipped
      add_recent "skipped" "$basename"
      clear_worker_status "$worker_id"
      (( MONITOR_UI )) || note "[Worker $worker_id] SKIPPED: ${rel_path##*/} (already processed)"
      ;;
    *)  # Failed
      echo "FAILED:$src_file" > "$result_file"
      increment_failed
      add_recent "failed" "$basename"
      clear_worker_status "$worker_id"
      (( MONITOR_UI )) || warn "[Worker $worker_id] FAILED: ${rel_path##*/} (see $log_file)"
      ;;
  esac
}

# Parallel processing with job control
(( MONITOR_UI )) || say "Starting $MAX_WORKERS parallel workers..."
(( MONITOR_UI )) || echo ""

declare -a PIDS=()
declare -a FILE_ARRAY=()
WORKER_ID=0

# Convert file list to array (avoids heredoc stdin issues with backgrounded processes)
while IFS= read -r line; do
  [[ -n "$line" ]] && FILE_ARRAY+=("$line")
done <<< "$FILE_LIST"

# Process each file
for src_file in "${FILE_ARRAY[@]}"; do
  [[ -z "$src_file" ]] && continue

  # Verify file exists before queuing
  if [[ ! -f "$src_file" ]]; then
    (( MONITOR_UI )) || warn "File not found, skipping: $src_file"
    continue
  fi

  ((WORKER_ID++)) || true

  # Use modular worker ID for display (cycle through 1-MAX_WORKERS)
  display_worker_id=$(( ((WORKER_ID - 1) % MAX_WORKERS) + 1 ))

  # Launch worker in background (redirect stdin to prevent consuming from parent)
  process_worker "$src_file" "$display_worker_id" </dev/null &
  PIDS+=($!)
  ((PROCESSED++)) || true

  # If we've reached max workers, wait for one to finish
  while (( ${#PIDS[@]} >= MAX_WORKERS )); do
    # Wait for any job to finish
    for i in "${!PIDS[@]}"; do
      if ! kill -0 "${PIDS[$i]}" 2>/dev/null; then
        wait "${PIDS[$i]}" 2>/dev/null || true
        unset 'PIDS[i]'
      fi
    done
    # Compact the array
    PIDS=("${PIDS[@]}")
    # Small sleep to avoid busy-waiting
    (( ${#PIDS[@]} >= MAX_WORKERS )) && sleep 0.5
  done

done

# Wait for remaining workers
(( MONITOR_UI )) || say "Waiting for remaining workers to complete..."
for pid in "${PIDS[@]}"; do
  wait "$pid" 2>/dev/null || true
done

# Stop monitor UI
if (( MONITOR_UI )) && [[ -n "$MONITOR_PID" ]]; then
  kill "$MONITOR_PID" 2>/dev/null || true
  wait "$MONITOR_PID" 2>/dev/null || true
  show_cursor
  clear_screen
fi

# Collect results
SKIPPED=0
for result_file in "$RESULT_DIR"/result_*; do
  [[ -f "$result_file" ]] || continue
  result=$(cat "$result_file")
  case "$result" in
    SUCCESS:*)
      ((SUCCEEDED++)) || true
      echo "${result#SUCCESS:}" >> "$SUCCESS_LOG"
      ;;
    SKIPPED:*)
      ((SKIPPED++)) || true
      ;;
    *)
      ((FAILED++)) || true
      echo "${result#FAILED:}" >> "$FAILED_LOG"
      ;;
  esac
done

# Summary
echo ""
say "=== Complete ==="
note "Processed: $PROCESSED"
note "Succeeded: $SUCCEEDED"
(( SKIPPED > 0 )) && note "Skipped:   $SKIPPED (already processed)"
note "Failed:    $FAILED"
note "Logs:      $LOG_DIR"

if [[ -s "$FAILED_LOG" ]]; then
  warn "Some files failed. Check logs in $LOG_DIR"
fi

(( FAILED > 0 )) && exit 1
exit 0
