#!/usr/bin/env bash
# =============================================================================
#  muxm-batch - Parallel batch processor for muxm
#  Processes directories of video files with configurable parallel workers
# =============================================================================

set -euo pipefail

# ---------- Defaults ----------
MAX_WORKERS="${MAX_WORKERS:-6}"
RECURSIVE="${RECURSIVE:-1}"
SKIP_EXISTING="${SKIP_EXISTING:-1}"
FILE_EXTENSIONS="${FILE_EXTENSIONS:-mkv,mp4,avi,mov,m4v,ts,wmv,webm,flv}"
LOG_DIR=""
DRY_RUN=0
VERBOSE=0

# ---------- Colors ----------
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ---------- Helpers ----------
say()  { echo -e "${BLUE}[muxm-batch]${NC} $*"; }
note() { echo -e "${GREEN}[muxm-batch]${NC} $*"; }
warn() { echo -e "${YELLOW}[muxm-batch]${NC} $*" >&2; }
die()  { echo -e "${RED}[muxm-batch]${NC} $*" >&2; exit 1; }

print_usage() {
  cat <<EOF
muxm-batch - Parallel batch processor for muxm

Usage: muxm-batch [OPTIONS] INPUT_DIR [OUTPUT_DIR]

Arguments:
  INPUT_DIR             Source directory containing video files
  OUTPUT_DIR            Destination directory (default: INPUT_DIR)

Options:
  -w, --workers N       Max parallel workers (default: $MAX_WORKERS)
  -r, --recursive       Process subdirectories (default: on)
  -R, --no-recursive    Only process INPUT_DIR, no subdirs
  -s, --skip-existing   Skip if output file exists (default: on)
  -f, --force           Overwrite existing outputs
  -e, --extensions LIST Comma-separated extensions (default: $FILE_EXTENSIONS)
  -l, --log-dir DIR     Directory for logs (default: ./muxm-batch-logs)
  --retry FILE          Retry failed files from a previous failed log
  --dry-run             List files that would be processed
  -v, --verbose         Verbose output
  -h, --help            Show this help

Examples:
  # Process all videos in /media/movies, output to same location
  muxm-batch /media/movies

  # Process with different output directory
  muxm-batch /media/source /media/converted

  # Process with 4 workers, only mkv files
  muxm-batch -w 4 -e mkv /media/movies

  # Retry previously failed files
  muxm-batch --retry ./muxm-batch-logs/failed-20250101-120000.txt

Worker recommendations:
  - NVENC sessions: Tesla P4 handles 2-3 concurrent NVENC encodes
  - Passthrough jobs: Can run many more (mostly I/O bound)
  - Default 6 workers balances NVENC queue and passthrough parallelism
EOF
}

# ---------- Parse Arguments ----------
INPUT_DIR=""
OUTPUT_DIR=""
RETRY_FILE=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    -w|--workers)       MAX_WORKERS="${2:-}"; shift 2 ;;
    -r|--recursive)     RECURSIVE=1; shift ;;
    -R|--no-recursive)  RECURSIVE=0; shift ;;
    -s|--skip-existing) SKIP_EXISTING=1; shift ;;
    -f|--force)         SKIP_EXISTING=0; shift ;;
    -e|--extensions)    FILE_EXTENSIONS="${2:-}"; shift 2 ;;
    -l|--log-dir)       LOG_DIR="${2:-}"; shift 2 ;;
    --retry)            RETRY_FILE="${2:-}"; shift 2 ;;
    --dry-run)          DRY_RUN=1; shift ;;
    -v|--verbose)       VERBOSE=1; shift ;;
    -h|--help)          print_usage; exit 0 ;;
    -*)                 die "Unknown option: $1" ;;
    *)
      if [[ -z "$INPUT_DIR" ]]; then
        INPUT_DIR="$1"
      elif [[ -z "$OUTPUT_DIR" ]]; then
        OUTPUT_DIR="$1"
      else
        die "Unexpected argument: $1"
      fi
      shift
      ;;
  esac
done

# Handle retry mode
if [[ -n "$RETRY_FILE" ]]; then
  [[ ! -f "$RETRY_FILE" ]] && die "Retry file not found: $RETRY_FILE"
  say "Retry mode: processing files from $RETRY_FILE"
fi

# Validate input
if [[ -z "$RETRY_FILE" ]]; then
  [[ -z "$INPUT_DIR" ]] && { print_usage; die "INPUT_DIR is required"; }
  [[ ! -d "$INPUT_DIR" ]] && die "INPUT_DIR does not exist: $INPUT_DIR"
fi

# Set defaults
[[ -z "$OUTPUT_DIR" ]] && OUTPUT_DIR="$INPUT_DIR"
[[ -z "$LOG_DIR" ]] && LOG_DIR="./muxm-batch-logs"

# Create log directory
mkdir -p "$LOG_DIR"

# Generate log filenames with timestamp
TIMESTAMP="$(date +%Y%m%d-%H%M%S)"
FAILED_LOG="$LOG_DIR/failed-$TIMESTAMP.txt"
SUCCESS_LOG="$LOG_DIR/success-$TIMESTAMP.txt"
PROGRESS_LOG="$LOG_DIR/progress-$TIMESTAMP.txt"

# Initialize logs
: > "$FAILED_LOG"
: > "$SUCCESS_LOG"
: > "$PROGRESS_LOG"

# ---------- Find muxm script ----------
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MUXM_BIN="$SCRIPT_DIR/muxm"
[[ ! -x "$MUXM_BIN" ]] && MUXM_BIN="$(command -v muxm 2>/dev/null || true)"
[[ ! -x "$MUXM_BIN" ]] && die "Cannot find muxm script. Ensure it's in PATH or same directory."

# ---------- Build file list ----------
build_file_list() {
  local find_cmd="find \"$INPUT_DIR\""
  (( RECURSIVE == 0 )) && find_cmd+=" -maxdepth 1"
  find_cmd+=" -type f \\("

  local first=1
  IFS=',' read -ra exts <<< "$FILE_EXTENSIONS"
  for ext in "${exts[@]}"; do
    ext="$(echo "$ext" | tr -d '[:space:]')"
    (( first )) && first=0 || find_cmd+=" -o"
    find_cmd+=" -iname \"*.$ext\""
  done
  find_cmd+=" \\)"

  eval "$find_cmd" 2>/dev/null | sort
}

# ---------- Process single file ----------
process_file() {
  local src="$1"
  local input_dir="$2"
  local output_dir="$3"
  local skip_existing="$4"
  local log_dir="$5"
  local muxm_bin="$6"
  local progress_log="$7"
  local success_log="$8"
  local failed_log="$9"

  # Calculate relative path and output path
  local rel_path="${src#$input_dir/}"
  [[ "$rel_path" == "$src" ]] && rel_path="$(basename "$src")"
  local out_path="$output_dir/${rel_path%.*}.mp4"
  local out_dir="$(dirname "$out_path")"

  # Create safe log filename
  local safe_name="$(echo "$rel_path" | tr '/' '_' | tr ' ' '_')"
  local log_file="$log_dir/${safe_name}.log"

  # Skip if output exists
  if (( skip_existing )) && [[ -f "$out_path" ]]; then
    echo "SKIP: $rel_path (exists)" >> "$progress_log"
    return 0
  fi

  # Create output directory
  mkdir -p "$out_dir"

  # Run muxm
  if "$muxm_bin" "$src" "$out_path" > "$log_file" 2>&1; then
    echo "$rel_path" >> "$success_log"
    echo "OK: $rel_path" >> "$progress_log"
    return 0
  else
    echo "$src" >> "$failed_log"
    echo "FAIL: $rel_path (see $log_file)" >> "$progress_log"
    return 1
  fi
}

# Export function and variables for parallel execution
export -f process_file
export INPUT_DIR OUTPUT_DIR SKIP_EXISTING LOG_DIR MUXM_BIN
export PROGRESS_LOG SUCCESS_LOG FAILED_LOG

# ---------- Main execution ----------
say "=== muxm-batch ==="
say "Input:      $INPUT_DIR"
say "Output:     $OUTPUT_DIR"
say "Workers:    $MAX_WORKERS"
say "Recursive:  $( (( RECURSIVE )) && echo 'yes' || echo 'no' )"
say "Skip exist: $( (( SKIP_EXISTING )) && echo 'yes' || echo 'no' )"
say "Extensions: $FILE_EXTENSIONS"
say "Logs:       $LOG_DIR"
echo ""

# Get file list
if [[ -n "$RETRY_FILE" ]]; then
  FILE_LIST="$(cat "$RETRY_FILE")"
  TOTAL_FILES="$(echo "$FILE_LIST" | grep -c . || echo 0)"
else
  FILE_LIST="$(build_file_list)"
  TOTAL_FILES="$(echo "$FILE_LIST" | grep -c . || echo 0)"
fi

say "Files found: $TOTAL_FILES"
echo ""

if (( TOTAL_FILES == 0 )); then
  note "No files to process."
  exit 0
fi

# Dry run mode
if (( DRY_RUN )); then
  say "DRY-RUN: Files that would be processed:"
  echo "$FILE_LIST" | while read -r f; do
    [[ -n "$f" ]] && echo "  $f"
  done
  exit 0
fi

# Process files
PROCESSED=0
SUCCEEDED=0
FAILED=0

# Check for GNU parallel
if command -v parallel &>/dev/null; then
  note "Using GNU parallel for processing..."

  echo "$FILE_LIST" | parallel --bar --jobs "$MAX_WORKERS" --halt soon,fail=20% \
    process_file {} "$INPUT_DIR" "$OUTPUT_DIR" "$SKIP_EXISTING" "$LOG_DIR" "$MUXM_BIN" "$PROGRESS_LOG" "$SUCCESS_LOG" "$FAILED_LOG" \
    || true
else
  note "GNU parallel not found. Using sequential processing with background jobs..."

  # Process using background jobs with job control
  declare -a PIDS=()

  while IFS= read -r src_file; do
    [[ -z "$src_file" ]] && continue

    # Wait if we have max workers running
    while (( ${#PIDS[@]} >= MAX_WORKERS )); do
      # Wait for any job to finish
      for i in "${!PIDS[@]}"; do
        if ! kill -0 "${PIDS[$i]}" 2>/dev/null; then
          wait "${PIDS[$i]}" 2>/dev/null || true
          unset 'PIDS[$i]'
        fi
      done
      # Reindex array
      PIDS=("${PIDS[@]}")
      sleep 0.5
    done

    # Start new job
    (
      process_file "$src_file" "$INPUT_DIR" "$OUTPUT_DIR" "$SKIP_EXISTING" "$LOG_DIR" "$MUXM_BIN" "$PROGRESS_LOG" "$SUCCESS_LOG" "$FAILED_LOG"
    ) &
    PIDS+=($!)

    ((PROCESSED++)) || true
    (( VERBOSE )) && echo "Started: $src_file (PID: ${PIDS[-1]})"
  done <<< "$FILE_LIST"

  # Wait for remaining jobs
  for pid in "${PIDS[@]}"; do
    wait "$pid" 2>/dev/null || true
  done
fi

# Count results
SUCCEEDED="$(wc -l < "$SUCCESS_LOG" 2>/dev/null | tr -d '[:space:]' || echo 0)"
FAILED="$(wc -l < "$FAILED_LOG" 2>/dev/null | tr -d '[:space:]' || echo 0)"
SKIPPED="$(grep -c "^SKIP:" "$PROGRESS_LOG" 2>/dev/null || echo 0)"

echo ""
say "=== Complete ==="
note "Success: $SUCCEEDED"
note "Failed:  $FAILED"
note "Skipped: $SKIPPED"
note "Logs:    $LOG_DIR"

if [[ -s "$FAILED_LOG" ]]; then
  warn "Some files failed. Retry with:"
  warn "  muxm-batch --retry $FAILED_LOG"
fi

# Exit with error if any failures
(( FAILED > 0 )) && exit 1
exit 0
